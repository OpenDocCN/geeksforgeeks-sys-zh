# HTTP 中的会话管理

> 原文:[https://www.geeksforgeeks.org/session-management-in-http/](https://www.geeksforgeeks.org/session-management-in-http/)

HTTP 是一种“无状态”协议。这意味着没有“内置”标准来跟踪相关的请求。每个请求都被视为独立的。目前，大多数网络应用程序使用的是 1996 年发布的 HTTP 1.1。这些 web 应用程序非常高级，通常处理复杂的操作，需要一对以上的请求/响应才能完成，这需要一些东西来跟踪操作的当前状态。这些应用程序还向每个用户呈现定制的内容。这需要在多个请求中识别用户。所以肯定有什么东西给 HTTP 增加了“增强”。
有一些解决方案是网络程序员聪明思考的结果。

HTTP 使用客户端-服务器架构，并使用 TCP 作为其传输协议，多个请求可以仅通过一个 TCP 连接发送，但客户端和服务器都认为这些是独立的。如上所述，HTTP 中的会话有两个方面。主要有两种方法来实现跨请求的跟踪。

**1。请求参数:**
表示多步骤流程当前状态或标识用户的令牌可以由服务器存储在网页的表单字段中，该字段将在用户每次执行操作时自动提交。令牌包含在输入字段的值中。该令牌可以作为 GET 请求参数或 POST 请求参数提交。GET 请求中的请求参数嵌入在 URL 中，并记录在浏览器历史记录中。而 POST 将参数作为请求主体提交，这样就不会嵌入到 URL 中，也不会显示在浏览器历史记录中。显然，对于提交敏感信息，应该使用 POST 请求，而 GET 请求可以用于敏感信息。例如，如果令牌是用户的标识符，它必须总是在开机自检请求中发送。令牌的非敏感示例包括状态标识符、引用值等。
在 GET 请求中还有另一种发送标识符的方式。它使用路径名而不是参数。

**2。cookie**
cookie 是存储在浏览器中的名称-值对，在后续请求中自动提交。服务器生成它们，并使用“set-cookie”HTTP 头将其发送给客户端。使用“cookie”头提交 cookie。

cookie 头发送用分号分隔的名称-值对。set-cookie 头包含 cookie 的额外指令和参数。这些有助于浏览器理解如何以及何时提交它们。
最常见的参数是- domain、path 和 expires，而指令是–“secure”和“httponly”。domain 参数指定 cookie 对其有效的域，cookie 也将对其所有子域有效。路径参数指定网址路径。过期是不言自明的。
“安全”指令指示浏览器仅通过 HTTPS 发送 cookie，而“httponly”指令则指示浏览器不要让网站 JavaScript 访问 cookie。这样做是为了防止 XSS 窃取 cookies，以防网站易受 XSS 攻击。

**最佳实践**
跟踪会话需要生成、传输和存储敏感令牌。任何阶段的任何错误配置都可能危及用户数据的安全。在开发维护用户会话的应用程序时，有几点应该牢记在心。

*   切勿通过未加密的通道(HTTP)发送任何令牌。
*   当用户注销时，使服务器端的令牌无效，仅仅清除用户浏览器上的 cookies 是不够的，可能会导致永久的帐户接管。
*   始终对需要身份验证的敏感操作实施 CSRF 保护。
*   永远不要在 GET 请求中提交反 CSRF 令牌(甚至不要考虑在 GET 请求中提交会话令牌)
*   生成敏感令牌时，请始终使用随机数和填充，并避免使用像 Base64 这样的可逆编码方案。
*   不要以明文形式在服务器上存储密码。总是散列它们并存储散列。这将保护用户免受不幸的数据泄露事件的影响。