# 使用 Java 实现字节填充

> 原文:[https://www . geeksforgeeks . org/implementing-byte-filling-use-Java/](https://www.geeksforgeeks.org/implementing-byte-stuffing-using-java/)

**需要字节填充**
在数据链路层的可变大小帧中，我们需要定义一种将一帧与下一帧分开的方法。字节填充被用来完成任务。在**字节填充**中，一个 8 位标志(‘F’)被添加在帧的开头和结尾，从而区分一帧和下一帧。因此，每次遇到标志序列(“F”)时，它都表示帧的开始或结束。然而，如果标志模式(‘F’)出现在帧本身携带的数据中，这种巧妙的方案将会引起差异。字节填充在这里有所帮助，只要标志模式出现在帧携带的数据中，就在标志模式之前用额外的 8 位转义序列(“E”)填充原始数据。然后，接收器将不得不去填充转义序列，以便获得原始数据。
此时可能出现的一个简单问题是，如果转义序列(' E ')构成了要发送的数据的一部分，该怎么办！这种情况的处理方式与上述完全相同，即在构成数据一部分的转义序列之前，向原始数据添加一个额外的 8 位转义序列(“E”)。
在面向字符的协议中，要传输的数据是 8 位字符，使用字节填充来处理上面讨论的问题。
为了简单起见，我们将只考虑发送数据中的三种字节序列，如:
**F** :标志序列
**E** :转义序列
**D** :任何其他数据序列
例如:

```
At Sender Side
Enter the Message to be Sent : 
DDEDFFDE
The data being sent (with byte stuffed) is : FDDEEDEFEFDEEF
Sending Message....
Thanks for the Feedback Server!!

At Receiver Side
Message Received...Successfully!!!
The Stuffed Message is : FDDEEDEFEFDEEF
The Destuffed Message is : DDEDFFDE
Messaging is over.....EXITING
```

从上面的例子我们可以看到原始数据是如何在接收端恢复的。
**在发送方(客户端)**
接近

1.  **发送端的每一帧数据首先在每一帧的开始和结束处填充 8 位标志序列(“F”)。**
2.  **接下来，扫描数据以查看是否有任何类似的标志序列(“F”)构成它的一部分。如果是，那么在每个这样的标志序列之前，填充一个额外的转义序列(“E”)。**
3.  **现在，如果发现任何类似的转义序列(' E ')构成了要发送的数据的一部分，则在每个这样的转义序列出现之前填充一个额外的转义序列(' E ')。**
4.  **最后，这个填充的数据由发送者发送。

    1.  接收器跳过接收到的数据的第一个和最后一个字节，因为它们仅分别用于发信号通知一个帧的开始和结束，并且不携带任何有用的数据。
    2.  从下一个字节开始，数据被扫描，如果连续发现两个转义序列(“E”)，则第一个转义序列被删除。类似地，如果一个转义序列后跟一个标志序列(' F ')，则前者被取消填充。
    3.  这种策略有助于接收方准确地恢复实际发送的数据。**