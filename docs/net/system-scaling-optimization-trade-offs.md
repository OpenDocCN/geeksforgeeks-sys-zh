# 系统扩展–优化权衡

> 原文:[https://www . geesforgeks . org/system-scaling-optimization-权衡/](https://www.geeksforgeeks.org/system-scaling-optimization-trade-offs/)

**网络负载均衡器(NLB)** 可以处理流量峰值，每秒处理数百万个请求然而，它不支持日志记录，所以使用 cloudwatch 将所有日志集中在一个地方。水平缩放前需要思考的问题。

*   确保线程安全的代码–用于水平缩放
*   连接池，实例化时没有直接连接
*   数据管理

**各种水平缩放选项:**

*   **Heroku–**配置 dyno 数量，增加单个 dyno 的功率。
*   **HirePower–**提供细粒度控制、动力和灵活性。
*   蔚蓝的
*   谷歌云
*   自动警报系统
*   还有更多的供应商

**网络服务器并发设置:**

*   Puma(对于 Ruby/Rack)-通过 web_concurrency 标志工作的人数，线程数。
*   NginX–实现高性能、稳定性、丰富的功能集、简单的配置、低资源消耗。
*   Apache–用于 java web 应用程序

[**【垂直缩放】**](https://www.geeksforgeeks.org/overview-of-scaling-vertical-and-horizontal-scaling/) **:**
放大一个系统叫做垂直缩放。
**优点–**

*   提高每台服务器的功率，以实现所需的性能。

**cons–**

*   对我们可以在一个实例上纵向扩展多少的昂贵而实用的限制。
*   扩展配置取决于将成本、性能和资源使用平衡到可接受的水平。

**使用缓存进行事务性查询:**
在缓存之前，我们需要得到问题的答案:提供最终的一致性可以吗，还是需要数据的强一致性。为了最终的一致性–[NoSQL](https://www.geeksforgeeks.org/introduction-to-nosql/)数据库。对于强一致性/关键交易–关系数据库管理系统–支付交易示例。

**快取─redis/memcached:**
**【redis】**
自动复制，快照。

**Memcached–**
多线程架构。
**缓存类型:**

*   **全局缓存–**
    简单，只有达到一定规模才有效。

*   **分布式缓存–**
    API 网关，cloud front–Lambda @ edge。

**如何选择正确的缓存:**

*   系统写得多还是读得少–(基于时间的日志)。
*   数据是一次写入多次读取–(用户配置文件)。
*   返回的数据总是唯一的吗–(搜索引擎)。

**一旁缓存:**

*   通用，最适合读取繁重的工作负载。(Memecached，Redis)。
*   系统对缓存故障具有弹性。
*   缓存中的数据模型可以不同于数据库中的数据模型。(针对–请求 id 存储的多个查询响应的结果)。
*   常见的写入策略是–直接写入数据库。TTL 用于服务陈旧数据，直到 TTL 到期。如果需要数据新鲜度，我们可以使缓存条目无效，或者使用直写缓存方法。
*   延迟加载数据

**通过缓存读取:**

*   与数据库保持一致。
*   在缓存未命中的情况下，缓存由数据库命中填充。
*   延迟加载数据。
*   最适合阅读繁重的工作负载-(新闻故事)

**Cons–**
第一次总是缓存未命中。通过手动查询加热/预热缓存。数据可能会变得不一致，写策略将是解决方案。
**差异 b/w 缓存在一旁和通过缓存读取:**
**缓存在一旁–**

*   应用程序负责从数据库中获取数据并填充缓存。
*   Data model can be different.

    **通过缓存读取–**

*   库或独立缓存提供程序支持逻辑。
*   数据模型将与数据库相同。

**通过缓存写入–缓存写入策略:**
**绕写–**
当第一个读取请求到来时，首先将数据写入数据库，然后将数据写入缓存。

*   它可以与只读和缓存相结合。
*   当数据只写入一次，读取频率较低或从不读取时，性能良好。(实时日志/聊天室消息)

**直写–**
数据首先写入缓存，然后写入数据库。可以结合通读。

*   额外的写入延迟。
*   保证一致性–无需使用任何缓存失效技术(DAX–Dynamo DB 加速器)。
*   DAX 可以用作写缓存。应用程序可以写入 Dynamodb，并通过 DAX 读取它。可能的问题–负缓存条目，当 DAX 在取消删除 dynamodb 表中找不到请求的项目时，DAX 向用户返回一个空结果，而不是错误。

**写回–**
将数据写入缓存，缓存会立即确认，经过一段时间的延迟后，它会将数据写回数据库。

*   也叫写在后面。
*   提高性能，有利于写入繁重的工作负载。
*   当与通读结合使用时，非常适合混合工作负载，其中最新更新和评估的数据始终在缓存中可用。
*   对数据库故障有弹性，可以容忍一些数据库停机时间。
*   如果支持批处理或合并，它可以减少对数据库的整体写入，降低负载，并降低对请求数量收费的数据库的成本(动态数据库)。
*   DAX 是直写的(因此对于写量大的应用程序，Dynamo 数据库成本不会降低)

**注意–**
如果我们将 Redis 用于两个缓存，并在峰值负载期间回写以更好地吸收峰值，那么在缓存故障的情况下，数据可能会永久丢失。
**缓存驱逐政策:**

*   Least 最近最少使用。大多用在任何地方，在搜索引擎中也是如此。
*   随机替换，先进先出–不经常使用。

**N+1 个查询:**
需要其他查询才能获得数据全貌的查询。根本原因-架构问题或对数据检索考虑的疏忽。解决方案–立即加载相关记录，即在初始查询中提取的记录。
**低效代码**

*   避免做资源密集型的事情。
*   转向更快的图书馆。
*   流–使用流上传 excel 或其他数据密集型加载任务，以最大限度地减少内存和 CPU 占用。
*   将集合遍历移动到数据库，例如
    *   在 RDBMS 中计算记录的总和，而不是在代码中计算。使用单一聚合数据库查询。
    *   避免急于加载整个文档，因为只有很少的字段会被访问。

**背景介绍:**
识别并分离可以延迟几秒钟或可以由另一个系统处理的任务。使用队列，根据类型分离作业-事务性、用户触发的批量作业，分离队列中的关键作业-SQS。

使用读取副本来执行这些非关键任务，例如–

*   发送电子邮件
*   生成报告
*   上传配置/文档

**资产修改:**
在加载之前，确保所有资产都已压缩或优化。这将显著减少加载时间。使用部署脚本将压缩的前端资产(网络包)推送到 S3。S3 将通过设置内容编码和内容类型为 gzip 服务。尽可能实现部署自动化–使用 AWS、Terraform 提供的云信息。

**内存泄漏:**
避免内存泄漏，它们可以命中交换内存(在真实内存和虚拟内存之间交换数据(虚拟内存地址，在现代 CPU 中总是启用)就是“交换”。磁盘上的交换空间是交换空间)。避免重启服务器的权宜之计，试着找出实际原因。

**同地办公:**
确保所有需要的微服务都位于一个区域，以获得低延迟并加快所有查询和操作。

**参考资料:**
[维基百科](https://en.wikipedia.org/wiki/Scalability#:~:text=Scaling%20horizontally%20(out%2Fin),to%20a%20distributed%20software%20application.&text=Other%20workloads%2C%20such%20as%20large,be%20handled%20by%20scalable%20systems.)
[Redis vs Memcached](https://aws.amazon.com/elasticache/redis-vs-memcached/)
**更多系统设计概念参考–**

[https://lethain . com/大规模系统架构简介/](https://lethain.com/introduction-to-architecting-systems-for-scale/)