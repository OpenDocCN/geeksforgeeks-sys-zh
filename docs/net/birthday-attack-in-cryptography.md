# 密码学中的生日攻击

> 原文:[https://www . geesforgeks . org/生日-密码攻击/](https://www.geeksforgeeks.org/birthday-attack-in-cryptography/)

先决条件–[生日悖论](https://www.geeksforgeeks.org/birthday-paradox/)
**生日攻击**是属于蛮力攻击一类的密码攻击。它利用了概率论中生日问题背后的数学原理。如**生日悖论问题**所述，这种攻击的成功很大程度上取决于随机攻击尝试和固定程度的排列之间更高的冲突可能性。

**生日悖论问题–**
让我们来考虑一个有 30 个学生和一个老师的教室的例子。老师希望找到几对生日相同的学生。因此老师要求每个人的生日都要找到这样的一对。直觉上，这个值可能看起来很小。例如，如果老师确定一个特定的日期，比如说***10 月 10 日*** ，那么当天至少有一个学生出生的概率是***1–(364/365)<sup>30</sup>***，大约是 ***7.9%*** 。然而，使用以下公式，至少一名学生与任何其他学生生日相同的概率约为 70%**:** 

```
1 - 365!/((365 - n!) * (365<sup>n</sup>))  (substituting n = 30 here) 
```

****上述术语的推导:****

****假设–**
1。假设非闰年(因此是 365 天)。
2。假设一个人在一年中的任何一天出生的可能性都是一样的。
让我们考虑 n = 2。
P(两人生日相同)= 1–P(两人生日不同)
= 1 –( 365/365)*(364/365)
= 1–1 *(364/365)
= 1–364/365
= 1/365。
那么对于 N 个人来说，他们都有不同生日的概率是:
P(N 个人有不同的生日)=(365/365)*(365-1/365)*(365-2/365)*…。(365-n+1)/365。
= 365！/((365-n)！* 365 <sup>n</sup>**

****哈希函数–**
哈希函数 H 是一个转换，它接受一个 ***可变大小的输入 m*** ，并返回一个 ***固定大小的字符串*** 称为一个 ***哈希值(h = H(m))*** 。密码学中选择的哈希函数必须满足以下要求:** 

*   **输入是可变长度的，**
*   **输出具有固定的长度，**
*   **对于任何给定的 x，H(x)相对容易计算，**
*   **H(x)是单向的，**
*   **H(x)无碰撞。** 

**如果散列函数 H 很难求逆，则称它是单向的，其中“很难求逆”意味着给定一个散列值 H，在计算上不可能找到某个输入 x 使得 ***H(x) = h*** 。**

**如果，给定一个消息 x，计算上不可能找到一个不等于 x 的消息 y 使得 ***H(x) = H(y)*** ，那么 H 被称为弱无冲突散列函数。**

**强无冲突散列函数 H 是这样一种函数，对于该函数，找到任意两条消息 x 和 y 使得 ***H(x) = H(y)*** 在计算上是不可行的。**

**让 **H: M = > {0，1} <sup>n</sup>** 成为一个哈希函数( **|M| > > 2 <sup>n</sup>** )**

**下面是一个通用算法，用于在时间 ***O(2 <sup>n/2</sup> )*** 哈希中查找冲突。**

****算法:**** 

1.  **在 M: m <sub>1</sub> ，m <sub>2</sub> 中选择 2 <sup>n/2</sup> 随机消息，…，m <sub>n/2</sub>**
2.  **对于 i = 1，2，…，2 <sup>n/2</sup> 计算 t<sub>I</sub>= H(m<sub>I</sub>)=>{ 0，1} <sup>n</sup>**
3.  **寻找碰撞(t <sub>i</sub> = t <sub>j</sub> )。如果没有找到，返回第 1 步** 

**我们考虑以下实验。从一组 H 值中，我们随机均匀地选择 n 个值，从而允许重复。让***p(n；H)*** 是在这个实验中至少有一个值被多次选择的概率。这个概率可以近似为:**

```
p(n; H) = 1 - ( (365-1)/365) * (365-2)/365) * ...(365-n+1/365))
p(n; H) = e<sup>-n(n-1)/(2H)</sup> = e<sup>-n2/(2H)</sup> 
```

****数字签名易受攻击性–**
数字签名可能容易受到生日攻击。消息 ***m*** 通常通过首先计算 ***H(m)*** 来签名，其中 ***H*** 是加密散列函数，然后使用一些秘密密钥来签名 ***H(m)*** 。假设爱丽丝想骗鲍勃签一份欺诈性的合同。爱丽丝准备了一份公平合同 ***m*** 和一份欺诈合同 ***m'*** 。然后，她找到了一些位置，在这些位置上 ***m*** 可以在不改变含义的情况下进行更改，例如在句子后面插入逗号、空行、一个空格对两个空格、替换同义词等。通过结合这些变化，她可以在 m 上创建大量的变体，这些变体都是公平的合同。**

**同样的，爱丽丝也可以在***m’***上做一些这样的改动来取，甚至更多，更接近 ***m*** ，也就是***H(m)= H(m’***。因此，爱丽丝现在可以将公平版 ***m*** 赠送给鲍勃签字。鲍勃签字后，爱丽丝接受了签字，并在上面附上了欺诈性的合同。这个签名证明鲍勃签署了欺诈性的合同。**

**为了避免这种攻击，散列函数的输出应该是非常长的比特序列，这样生日攻击现在在计算上变得不可行。**