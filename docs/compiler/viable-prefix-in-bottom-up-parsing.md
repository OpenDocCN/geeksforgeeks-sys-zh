# 自底向上解析中的可行前缀

> 原文:[https://www . geesforgeks . org/可行-前缀自下而上-解析/](https://www.geeksforgeeks.org/viable-prefix-in-bottom-up-parsing/)

**可行前缀**是右句形式的前缀，它不会延续到该句形式最右边手柄的右端。

这显然意味着一个可行的前缀在其最右端有一个句柄。并非所有正确句子形式的前缀都能出现在[移位缩减解析器](https://www.geeksforgeeks.org/shift-reduce-parser-compiler/)的堆栈上。

这可以通过下面的例子来说明。

**示例–**

```
A=>B+id=>(E)+id  
(rightmost derivation, sentential form) 
```

[自下而上的解析器](https://www.geeksforgeeks.org/difference-between-top-down-parsing-and-bottom-up-parsing/)给出了反向最右边的推导，因此在上面的例子中，如果我们在反向最右边的推导过程中得到字符串(E)+id，那么执行以下操作:

<center>

| 已执行的操作 | 堆 | 评论 |
| --- | --- | --- |
| (.E)+id | （ | 移位( |
| (英)+身份证 | (五) | E 档 |
| (五)。+id | (五) | 轮班) |
| B.+id | B | 把(英)降为(乙) |
| B+。身份证明（identification） | B + | shift + |
| B+id。 | B + id | 班次 id |
| A | A | 将 B + id 简化为 A |

</center>

正如我们在上表中看到的，在将+移动到堆栈之前，我们已经将(E)减少到了 b。因此，我们在堆栈上只能有(，(E)，(E)，但在堆栈上不能有(E)+因为(E)是一个句柄，堆栈中的项目不能超过该句柄。所以这里(、(E)、(E)都是句柄(E)的可行前缀，只有这些前缀出现在移位缩减解析器的堆栈中。

因此，我们不断移动项目，直到我们到达句柄或出现错误。一旦到达一个手柄，我们就使用合适的产品用非终端减少它。因此，可行的前缀有助于采取适当的降档决策。只要堆栈包含这些前缀，就不会有任何错误。

LR(0)自动机可以识别所有可行的前缀。因此，给定单反(1)解析器的可行前缀集是一种常规语言。栈与有限状态机的这种结合实际上是一种下推自动机，它实际上用于识别一种上下文无关的语言。

以下示例说明了给定语法的所有可行前缀。

**例–**
给定语法:

```
S -> AA
A -> bA | a 
```

给定字符串–

```
bbbaa 
```

**解决方案:**
正如我们所知，自下而上的解析是给定语法的最右边的字符串派生的逆过程。因此，我们使用字符串最右边的反向派生来演示这个示例。

<center>

| 没有。 | 带手柄的反向最右推导 | 可行前缀 | 评论 |
| --- | --- | --- | --- |
| 1. | S -> bbb **a** a | b、bb、bbb、bbba | 这里，a 是句柄，因此可行前缀不能超过 a。 |
| 2. | S -> bb **bA** a | b、bb、bbb、bbbA | 这里，bA 是句柄，因此可行前缀不能超过 bA。 |
| 3. | S -> b **bA** a | b、bb、bbA | 这里同样，bA 是句柄，因此可行前缀不能超过 bA。 |
| 4. | S -> **bA** a | b，bA | 这里同样，bA 是句柄，因此可行前缀不能超过 bA。 |
| 5. | S -> A **a** | a，Aa | 这里，a 是句柄，因此可行前缀不能超过 a。 |
| 6. | S -> **AA** | 一、AA | 这里，AA 是句柄，因此可行前缀不能超过 AA。 |

</center>