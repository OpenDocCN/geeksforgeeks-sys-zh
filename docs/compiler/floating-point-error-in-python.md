# Python 中的浮点错误

> 原文:[https://www . geesforgeks . org/python 中的浮点错误/](https://www.geeksforgeeks.org/floating-point-error-in-python/)

据了解`1.2 - 1.0 = 0.2`。但是当你在 python 中尝试同样的方法时，你会对结果感到惊讶:

```
>>> 1.2 - 1.0

```

**输出:**

```
0.199999999999999996
```

这在 Python 中可以被认为是一个 bug，但事实并非如此。这与 Python 关系不大，更多的是与底层平台如何处理浮点数有关。这是在系统内部处理浮点数时遇到的正常情况。这是浮点数内部表示时引起的问题，浮点数使用固定数量的二进制数字来表示十进制数字。用二进制表示一些十进制数是很困难的，所以在许多情况下，它会导致小的舍入误差。

我们知道十进制数学中类似的情况，有很多结果是不能用固定的小数位数来表示的，
**例**

```
10 / 3 = 3.33333333.......
```

在这种情况下，以 1.2 为例，二进制中 0.2 的表示为 `0.00110011001100110011001100......`等等。
这个无限小数内部很难存储。通常，浮点对象的值以固定精度存储在二进制浮点中(**通常为 53 位**)。

所以我们在内部将 **1.2** 表示为:

```
1.0011001100110011001100110011001100110011001100110011  
```

这完全等于:

```
1.1999999999999999555910790149937383830547332763671875
```

还是你在想为什么 **python 不解决这个问题**，其实和 python 没有关系。发生这种情况是因为底层 c 平台处理浮点数的方式，最终由于不准确，我们将一直把数字记为一串固定的数字。

请注意，这是二进制浮点的本质:这在 **Python** 或 **C** 中都不是 bug，在您的代码中也不是 bug。在支持我们硬件浮点运算的所有语言中，您都会看到相同的行为(尽管有些语言在默认情况下或在所有输出模式下可能不会显示差异)。当我们关心需要精确精度的数学问题或在条件语句中使用它时，我们必须考虑这种行为。
查看 python 文档中的[浮点](https://docs.python.org/3/tutorial/floatingpoint.html#tut-fp-issues)部分了解更多此类行为。