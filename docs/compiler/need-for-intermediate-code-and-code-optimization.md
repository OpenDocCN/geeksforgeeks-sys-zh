# 需要中间代码和代码优化

> 原文:[https://www . geesforgeks . org/需要中间代码和代码优化/](https://www.geeksforgeeks.org/need-for-intermediate-code-and-code-optimization/)

**[中间代码](https://www.geeksforgeeks.org/intermediate-code-generation-in-compiler-design/) :**
中间代码是机器无关的代码，但接近机器指令。语法树、后缀表示法、3 地址码、DAG 都可以作为中间语言。

**需要中间代码:**

1.  假设我们有 x 个源语言和 y 个目标语言:
    1.  **没有 ICG–**我们必须直接将每种源语言转换为目标语言，因此，对于每一个源-目标对，我们将需要一个编译器。因此，我们需要(x*y)编译器，这可能是一个非常大的数字，实际上是不可能的。
    2.  **有了 ICG–**我们将只需要 x 个编译器就能把每种源语言转换成中间代码。我们还需要 y 编译器将中间代码转换成 y 目标语言。
        所以，我们只需要(x+y)个编译器，而 ICG 比 x*y 个编译器要少得多。
2.  **重新定位变得容易:**
    可以通过将新机器的后端(生成目标代码)附加到现有前端(生成中间代码)来创建不同机器的编译器。
3.  **机器无关:**
    一个机器无关的代码优化器可以应用于中间代码。所以这可以在任何机器上运行。

*   **简单性:**
    中间代码足够简单，可以轻松转换成任何目标代码。因此，ICG 减少了目标代码生成的开销。*   **复杂度:**
    中间代码足够复杂，可以表示高级语言的所有复杂结构。*   **Modification:**
    We can easily modify our code to get better performance and throughput by applying optimization technique to the Intermediate code.

    **[代码优化](https://www.geeksforgeeks.org/code-optimization-in-compiler-design/) :**
    应用于目标代码(汇编代码)的代码优化是一种通过消耗更少的资源来改进代码的转换技术。代码优化有三种类型:

    1.  **机器相关优化–**目标代码(汇编代码)生成后应用的优化是机器相关优化。
    2.  **机器无关–**在这种情况下，编译器转换中间代码中不涉及任何 CPU 寄存器和/或绝对内存位置的部分。例如 3-地址码。
    3.  **局部优化–**在块(连续语句序列)中执行的优化是局部优化，例如 If-Else、switch-case、条件语句和循环(如 Do-While、For 和 repeat-直到)等。

    **代码优化需求:**

    1.  **环路降频:**
        环路优化是环路内的优化过程。这降低了表达式的计算频率，并将循环不变的语句带出循环。
    2.  **死代码消除:**
        它在不改变代码行为的情况下删除不必要的指令。
    3.  **速度:**
        代码优化增加了程序的速度。
    4.  **资源:**
        经过代码优化后，我们的程序对资源的需求更少，从而为其他程序员节省了我们的资源(即 cpu、内存)。
    5.  **整洁干净的代码:**
        去掉常用的子表达式和冗余代码后，我们的代码就变成了干净的代码。
    6.  **强度降低:**
        强度降低是指用简单(便宜/低强度)的操作员代替昂贵的操作员。
    7.  为了执行更少的迭代次数，我们使用代码优化。
    8.  每当两个循环共享相同的索引变量时，将它们的主体组合起来，也就是说，对于循环阻塞或循环融合，这是一种代码优化。