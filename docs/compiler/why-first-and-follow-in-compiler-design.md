# 为什么编译器设计要先有后有？

> 原文:[https://www . geesforgeks . org/why-先编译后设计/](https://www.geeksforgeeks.org/why-first-and-follow-in-compiler-design/)

<u>**为什么是 FIRST？**</u>
我们在《语法分析导论》的[前一篇](https://www.geeksforgeeks.org/introduction-to-syntax-analysis-in-compiler-design/)中看到了回溯的必要性，实现起来确实是一个复杂的过程。有更简单的方法来解决这个问题:

如果编译器事先知道什么是“应用生产规则时生成的字符串的第一个字符”，并将其与它看到的输入字符串中的当前字符或标记进行比较，它就可以明智地决定应用哪个生产规则。

让我们采用上一篇文章中的相同语法:

```
S -> cAd
A -> bc|a 
And the input string is “cad”. 
```

因此，在上面的例子中，如果它知道在读取输入字符串中的字符“c”并应用 S->cAd 后，输入字符串中的下一个字符是“A”，那么它将忽略产生规则 A->bc(因为“b”是由该产生规则产生的字符串的第一个字符，而不是“A”)，并直接使用产生规则 A->a ( <u>因为“A”是由该产生规则产生的字符串的第一个字符，并且与输入字符串的当前字符相同，该当前字符也是“A”</u>)。
因此验证了如果编译器/解析器知道通过应用产生式规则可以获得的字符串的第一个字符<u>，那么它可以明智地应用正确的产生式规则来获得给定输入字符串的正确语法树。</u>

<u>**为什么跟随？**</u>
解析器还面临一个问题。让我们考虑下面的语法来理解这个问题。

```
 A -> aBb
 B -> c | ε
 And suppose the input string is “ab” to parse. 
```

由于输入中的第一个字符是 A，解析器应用规则 A->aBb。

```
          A
        / |  \
      a   B   b
```

现在解析器检查输入字符串的第二个字符是 B，要派生的 Non-Terminal 是 B，但是解析器不能得到任何包含 B 作为第一个字符的可从 B 派生的字符串。
但是语法确实包含一个产生规则 B - > ε，如果应用了这个规则，那么 B 将消失，解析器得到输入“ab”，如下所示。但是解析器只有在知道生产规则中跟随 B 的字符与输入中的当前字符相同时，才能应用它。

在 A -> aBb 的 RHS 中，B 跟随非终端 B，即 FOLLOW(B) = {b}，当前读取的输入字符也是 B，因此解析器应用这个规则。它能够从给定的语法中得到字符串“ab”。

```
           A                    A
        /  |  \              /    \                                                
      a    B    b    =>     a      b       
           |
           ε 
```

因此，如果需要从解析树生成字符串，FOLLOW 可以使非终结符消失。

结论是，我们需要为给定的语法找到 FIRST 和 FOLLOW 集合，以便解析器可以在正确的位置正确地应用所需的规则。

在下一篇文章中，我们将讨论 FIRST 和 FOLLOW 的正式定义，以及计算这些集合的一些简单规则。

[语法分析小测验](https://www.geeksforgeeks.org/parsing-and-syntax-directed-translation-gq/)

本文由 [**瓦伊巴夫巴派**](https://disqus.com/by/vaibhav2992/) 编撰。如果您发现任何不正确的地方，或者您想分享更多关于上面讨论的主题的信息，请写评论