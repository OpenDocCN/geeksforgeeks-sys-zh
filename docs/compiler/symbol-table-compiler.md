# 编译器中的符号表

> 原文:[https://www.geeksforgeeks.org/symbol-table-compiler/](https://www.geeksforgeeks.org/symbol-table-compiler/)

**先决条件–**[编译器的阶段](https://www.geeksforgeeks.org/compiler-design-phases-compiler/)

**符号表**是编译器为了跟踪变量的语义而创建和维护的重要数据结构，即它存储关于范围的信息和关于名称的绑定信息，关于各种实体的实例的信息，例如变量和函数名称、类、对象等。

*   它内置了词法和语法分析阶段。
*   这些信息由编译器的分析阶段收集，并由编译器的合成阶段用来生成代码。
*   编译器使用它来实现编译时效率。
*   它由编译器的不同阶段使用，如下所示
    1.  **词法分析:**在表中创建新的表条目，例如关于令牌的条目。
    2.  **语法分析:**在表中添加属性类型、范围、维度、引用行、用途等信息。
    3.  **语义分析:**使用表中的可用信息来检查语义，即验证表达式和赋值在语义上是正确的(类型检查)，并相应地进行更新。
    4.  **中间代码生成:**参考符号表，了解分配了多少以及什么类型的运行时，该表有助于添加临时变量信息。
    5.  **代码优化:**使用符号表中的信息进行机器相关的优化。
    6.  **目标代码生成:**使用表中存在的标识符的地址信息生成代码。

**符号表条目–**符号表中的每个条目都与支持编译器不同阶段的属性相关联。

**符号表中存储的项目:**

*   变量名和常量
*   过程和函数名
*   文字常量和字符串
*   编译器生成的临时对象
*   源语言中的标签

**编译器从符号表中使用的信息:**

*   数据类型和名称
*   申报程序
*   存储中的偏移量
*   如果是结构或记录，则是指向结构表的指针。
*   对于参数，参数是通过值传递还是通过引用传递
*   传递给函数的参数的数量和类型
*   基址

**符号表的操作–**在符号表上定义的基本操作包括:

![](img/e0b66a00df56e4f332b469fc5e3f61e8.png)

**符号表的实现–**
以下是实现符号表的常用数据结构:-

1.  **列表–**
    *   在此方法中，数组用于存储名称和相关信息。
    *   指针**“可用”**保持在所有存储记录的末尾，新的名称按照它们到达的顺序添加
    *   要搜索一个名字，我们从列表的开头开始，直到可用的指针，如果没有找到，我们会得到一个错误**“使用未声明的名字”**
    *   插入新名称时，我们必须确保它不存在，否则会出现错误，即**“多个已定义的名称”**
    *   插入很快，但对于大型表，查找很慢，平均为 0(n)
    *   优点是占用的空间最小。
2.  [**链表**](https://www.geeksforgeeks.org/data-structures/linked-list/)**–**
    *   这个实现使用了一个链表。每个记录都添加了一个链接字段。
    *   名称搜索是按照链接字段的链接所指向的顺序进行的。
    *   保持指针**“第一”**指向符号表的第一条记录。
    *   插入很快，但对于大型表，查找很慢，平均为 0(n)
3.  **哈希表** ***   在哈希方案中，维护两个表——哈希表和符号表，并且是实现符号表最常用的方法。
    *   哈希表是索引范围为 0 到表大小–1 的数组。这些条目是指向符号表名称的指针。
    *   为了搜索一个名称，我们使用了一个散列函数，它将产生一个 0 到表大小-1 之间的整数。
    *   插入和查找可以变得非常快。
    *   优点是可以快速搜索，缺点是哈希实现起来很复杂。** 
4.  **[**【二叉查找树】**](https://www.geeksforgeeks.org/binary-search-tree-data-structure/)**–**

    *   实现符号表的另一种方法是使用二叉查找树，即我们添加两个链接字段，即左子字段和右子字段。
    *   所有名称都是作为始终遵循二叉查找树属性的根节点的子节点创建的。
    *   插入和查找平均为 0(log<sub>2</sub>n)。**