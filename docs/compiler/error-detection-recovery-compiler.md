# 编译器中的错误检测和恢复

> 原文:[https://www . geesforgeks . org/error-detection-recovery-compiler/](https://www.geeksforgeeks.org/error-detection-recovery-compiler/)

在编译的这个阶段，用户可能犯的所有错误都会被检测到，并以错误消息的形式报告给用户。这种定位错误并向用户报告的过程称为**错误处理过程**。
**错误处理程序的功能。**

*   侦查
*   报告
*   恢复

## 错误的分类

![](img/002781f65d07e5cc8966cd20b999a3ae.png)

### 编译时错误

编译时错误有三种类型:-

#### **词汇阶段错误**

这些错误是在词法分析阶段检测到的。典型的词汇错误有:

*   超过标识符或数字常量的长度。
*   非法字符的出现
*   不匹配的字符串

```
Example 1 : printf("Geeksforgeeks");$
This is a lexical error since an illegal character $ appears at the end of statement.

Example 2 : This is a comment */
This is an lexical error since end of comment is present but beginning is not present
```

**词汇错误的错误恢复:**

*紧急模式恢复*

*   在这种方法中，每次从输入中删除一个连续的字符，直到找到一组指定的同步标记。同步标记是分隔符，例如；或}
*   优点是易于实现，并保证不会进入无限循环
*   缺点是相当多的输入被跳过而没有检查它是否有额外的错误

#### **句法相位错误:**

这些错误是在语法分析阶段检测到的。典型的语法错误有:

*   结构错误
*   缺少运算符
*   拼写错误的关键词
*   不平衡括号

```
Example : swich(ch)
              {
                 .......
                 .......
              }
```

关键字**开关**被错误地写成 swich。因此，出现**“未识别关键字/标识符”**错误。

**语法阶段恢复的错误恢复:**

**1。紧急模式恢复**

*   在这种方法中，每次从输入中删除一个连续的字符，直到找到一组指定的同步标记。同步令牌是一种工具，例如；或}
*   优点是易于实现，并保证不会进入无限循环
*   缺点是相当多的输入被跳过而没有检查它是否有额外的错误

**2。语句模式恢复**

*   在这种方法中，当解析器遇到错误时，它会对剩余的输入执行必要的更正，以便输入语句的其余部分允许解析器提前解析。
*   更正可以是删除多余的分号，用分号替换逗号，或者插入缺少的分号。
*   进行校正时，应特别注意不要进入无限循环。
*   一个缺点是，它发现很难处理实际错误发生在检测点之前的情况。

**3。错误生产**

*   如果用户知道可能遇到的常见错误，那么可以通过用产生错误结构的错误产物来扩充语法来合并这些错误。
*   如果使用这种方法，则在解析过程中，可以生成适当的错误消息，并且可以继续解析。
*   缺点是很难维护。

**4。全局修正**

*   解析器检查整个程序，并试图找出最接近的无错匹配。
*   最接近匹配程序插入、删除和更改令牌的次数较少，可以从错误输入中恢复。
*   由于时间和空间的复杂性，这种方法实际上并没有实现。

### **语义错误**

这些错误是在语义分析阶段检测到的。典型的语义错误有

*   操作数类型不兼容
*   未声明的变量
*   实际参数与形式参数不匹配

```
Example : int a[10], b;
                 .......
                 .......
                 a = b;
```

因为 a 和 b 的类型不兼容，所以会产生语义错误。

**语义错误的错误恢复**

*   如果遇到错误**“未声明的标识符”**，则为了从该错误中恢复，为相应的标识符创建一个符号表条目。
*   如果两个操作数的数据类型不兼容，则由编译器进行自动类型转换。