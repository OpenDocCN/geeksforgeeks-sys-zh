# 编译器设计中的常数传播

> 原文:[https://www . geesforgeks . org/constant-propagation-in-compiler-design/](https://www.geeksforgeeks.org/constant-propagation-in-complier-design/)

常量传播是编译器设计中的**局部代码优化技术**之一。可以定义为表达式中变量的常数值替换的*过程。简单地说，我们可以说，如果某个值被赋予了一个已知的常数，那么我们可以简单地用常数来代替那个值。分配给变量的常量可以通过流程图传播，并且可以在使用变量时替换。*

在编译器中使用到达定义分析结果来执行常数传播，这意味着如果所有变量的到达定义具有相同的赋值，该赋值将相同的常数赋给该变量，则该变量具有常数值，并且可以用该常数替换。

假设我们使用 pi 变量，并为其赋值 22/7

```
pi = 22/7 = 3.14
```

在上面的代码中，编译器必须首先执行**除法运算**，这是一个**昂贵的运算**，然后将计算结果 3.14 分配给变量 pi。现在，如果任何时候我们必须使用 pi 的常量值，那么编译器必须再次查找该值，再次执行除法运算，然后将其赋给 pi，然后使用它。当我们可以直接将值 3.14 赋给 pi 变量，从而减少代码运行所需的时间时，这不是一个好主意。

此外，常数传播减少了值从一个位置或变量直接复制到另一个位置或变量的情况，以便简单地将其值分配给另一个变量。例如:

考虑以下伪代码:

```
a = 30
b = 20 - a /2
c = b * ( 30 / a + 2 ) -  a
```

我们可以看到，在第一个表达式中，值 a 被赋予了一个常量值，即 30。现在，当编译器开始执行第二个表达式时，它遇到了，所以它会转到第一个表达式来查找 a 的值，然后再次将 30 的值赋给 a，然后执行第二个表达式。现在它来到第三个表达式，再次遇到 b 和 a，然后它需要再次计算第一个和第二个表达式，以便计算 c 的值。因此，a 需要传播 3 次。这个过程非常耗时。

相反，我们可以将相同的代码重写为:

```
a = 30
b = 20 - 30/2
c = b * ( 30 / 30 + 2) - 30
```

与以前的代码相比，这个更新的代码更快，因为编译器不需要一次又一次地返回到以前的表达式查找和复制变量值来计算当前的表达式。这节省了大量时间，从而降低了时间复杂性并更高效地执行操作。

请注意，这种常量传播技术行为依赖于编译器，就像很少有编译器在基本块内执行常量传播操作一样；而少数编译器在更复杂的控制流中执行恒定的传播操作。