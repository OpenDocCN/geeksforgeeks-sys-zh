# 互斥体 vs 信号量

> 原文:[https://www.geeksforgeeks.org/mutex-vs-semaphore/](https://www.geeksforgeeks.org/mutex-vs-semaphore/)

互斥体和信号量有什么区别？什么时候应该使用互斥体，什么时候应该使用信号量？

设计/开发智能应用程序需要对操作系统概念有具体的理解。我们的目标是教育读者这些概念，并向其他专家极客学习。

按照操作系统术语，互斥体和信号量是提供同步服务的内核资源(也称为*同步原语*)。*为什么我们需要这样的同步原语？只有一个不够吗？*要回答这些问题，需要了解几个关键词。请阅读[原子性](https://www.geeksforgeeks.org/g-fact-57/)和[临界区](https://www.geeksforgeeks.org/g-fact-70/)的帖子。我们将通过示例说明如何理解这些概念，而不是遵循通常的操作系统文本描述。

**[**生产者-消费者**](http://en.wikipedia.org/wiki/Producer-consumer_problem) **问题:****

***注意内容是广义解释。实际细节因实施而异。***

**考虑标准的生产者-消费者问题。假设我们有一个 4096 字节长的缓冲区。生产者线程收集数据并将其写入缓冲区。使用者线程处理从缓冲区收集的数据。目标是，两个线程不应该同时运行。**

****使用互斥体:****

**互斥体提供互斥，生产者或消费者都可以拥有密钥(互斥体)并继续他们的工作。只要缓冲区被生产者填满，消费者就需要等待，反之亦然。**

**在任何时间点，只有一个线程可以使用整个*缓冲区。这个概念可以用信号量来概括。***

*****使用信号量:*****

***信号量是一种通用互斥体。代替单个缓冲区，我们可以将 4 KB 缓冲区分成四个 1 KB 缓冲区(相同的资源)。信号量可以与这四个缓冲区相关联。消费者和生产者可以同时使用不同的缓冲区。***

*****误解:*****

****二进制信号量*和*互斥量*之间存在歧义。我们可能会发现互斥体是一个二进制信号量。*但不是*！互斥和信号量的目的是不同的。也许，由于它们实现的相似性，互斥体会被称为二进制信号量。***

***严格来说，互斥是一种 **锁定机制** 用来同步对资源的访问。只有一个任务(可以是基于操作系统抽象的线程或进程)可以获取互斥体。这意味着存在与互斥相关联的所有权，并且只有所有者才能释放锁(互斥)。***

***信号量是 **的信号机制** (“我完成了，你可以进行”类信号)。例如，如果您在手机上听歌曲(假设它是一项任务)，同时您的朋友打电话给您，则会触发一个中断，中断服务程序(ISR)会向呼叫处理任务发出唤醒信号。***

*****一般问题:*****

****1。一个线程可以获得多个锁(互斥锁)吗？****

***是的，一个线程可能需要不止一个资源，因此需要锁。如果任何锁不可用，线程将等待(阻塞)锁。***

****2。互斥体可以被锁定多次吗？****

***互斥体是锁。只有一种状态(锁定/解锁)与之相关联。然而，*递归互斥体*可以被锁定多次(符合 POSIX 的系统)，其中有一个计数与之相关联，但只保留一个状态(锁定/解锁)。程序员必须解锁互斥锁的次数和它被锁定的次数一样多。***

****3。如果非递归互斥锁被锁定不止一次，会发生什么。****

***僵局。如果一个已经锁定了互斥体的线程试图再次锁定互斥体，它将进入互斥体的等待列表，这将导致死锁。这是因为没有其他线程可以解锁互斥体。操作系统实现者可以小心识别互斥体的所有者，如果互斥体已经被同一个线程锁定，则返回以防止死锁。***

****4。二进制信号量和互斥量相同吗？****

***不。我们建议将它们分开处理，正如在信号与锁定机制中所解释的那样。但是二进制信号量可能会遇到与互斥体相关的同样的关键问题(例如优先级反转)。我们将在后面的文章中介绍这些内容。***

***程序员可以选择互斥体，而不是创建计数为 1 的信号量。***

****5。什么是互斥和临界区？****

***一些操作系统在 API 中使用相同的单词*临界区*。通常互斥体是一个昂贵的操作，因为有相关的保护协议。最后，互斥的目标是原子访问。还有其他方法可以实现原子访问，比如禁用中断，这样可以更快，但会破坏响应。替代应用编程接口利用禁用中断。***

****6。什么是事件？****

***互斥、信号量、事件、临界区等的语义是相同的。都是同步原语。基于使用它们的成本，它们是不同的。我们应该查阅操作系统文档了解确切的细节。***

****7。我们能在中断服务例程中获取互斥体/信号量吗？****

***ISR 将在当前运行线程的上下文中异步运行。不建议**在 ISR 中查询(阻塞呼叫)同步原语的可用性。中断服务请求很短，对互斥/信号量的调用可能会阻塞当前正在运行的线程。然而，ISR 可以发出信号或解锁互斥体。*****

******8。当互斥体/信号量不可用时，我们所说的“线程阻塞”是什么意思？******

*****每个同步原语都有一个与之关联的等待列表。当资源不可用时，请求线程将从处理器的运行列表移动到同步原语的等待列表。当资源可用时，等待列表中优先级较高的线程获得资源(更准确地说，它取决于调度策略)。*****

******9。当资源不可用时，线程有必要总是阻塞吗？******

*****没必要。如果设计确定了在资源不可用时需要做什么，线程可以承担这项工作(不同的代码分支)。为了支持应用需求，操作系统提供了非阻塞应用编程接口。*****

*****例如 POSix pthread _ mutex _ try lock()API。当互斥体不可用时，函数立即返回，而应用编程接口 pthread_mutex_lock()阻塞线程，直到资源可用。*****

*******参考文献:*******

*****[**http://www.netrino.com/node/202**T3】](http://www.netrino.com/node/202)*****

*******http://doc . trolltech . com/4.7/qsemaphore . html*******

*****还要将互斥/信号量与彼得森算法和德克尔算法进行比较。一个很好的参考是*并发艺术*一书。也可以在 Qt 文档中探索读取器锁和写入器锁。*****

*******运动:*******

*****实现一个程序，当在同一个会话中执行多次时，它会打印一条消息“实例正在运行”。例如，如果我们在 Windows 中观察 word 应用程序或 Adobe reader，我们只能在任务管理器中看到一个实例。如何实施？*****

*****文由**文基**整理。如果你发现任何不正确的地方，或者你想分享更多关于上面讨论的话题的信息，请写评论。*****