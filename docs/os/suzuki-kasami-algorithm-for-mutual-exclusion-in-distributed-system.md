# 分布式系统中互斥的铃木-卡萨米算法

> 原文:[https://www . geesforgeks . org/Suzuki-kasami-分布式系统中互斥算法/](https://www.geeksforgeeks.org/suzuki-kasami-algorithm-for-mutual-exclusion-in-distributed-system/)

先决条件:[分布式系统中的互斥](https://www.geeksforgeeks.org/operating-system-mutual-exclusion-in-distributed-system/)

**铃木–卡萨米算法**是一种基于令牌的算法，用于在分布式系统中实现互斥。这是对 Ricart–Agrawala 算法的修改，这是一种基于权限(非基于令牌)的算法，使用 **REQUEST** 和 **REPLY** 消息来确保互斥。

在基于令牌的算法中，如果一个站点拥有唯一的令牌，它就被允许进入其关键部分。基于非令牌的算法使用时间戳对关键部分的请求进行排序，其中在基于令牌的算法中使用 as 序列号。

每个关键部分的请求都包含一个序列号。该序列号用于区分旧请求和当前请求。

**数据结构和符号:**

*   整数数组 **RN[1…N]**
    站点 S <sub>i</sub> 保留**RN<sub>I</sub>【1…N】**，其中**RN<sub>I</sub>【j】**是迄今为止通过 **REQUEST** 消息从站点 S <sub>i</sub> 接收到的最大序列号。
*   整数**LN【1…N】**
    的数组这个数组被令牌使用。 **LN[J]** 是站点 S 最近执行的请求的序列号 <sub>j</sub> 。
*   队列 **Q**
    这个数据结构被令牌用来记录等待令牌的站点的 ID

**算法:**

*   **进入临界区:**
    *   当站点 S <sub>i</sub> 想要进入临界区并且它没有令牌时，它递增它的序列号**RN<sub>I</sub>【I】**并且向所有其他站点发送请求消息 **REQUEST(i，sn)** ，以便请求令牌。
        这里 **sn** 是**RN<sub>I</sub>【I】**的更新值
    *   当站点 S <sub>j</sub> 从站点 S <sub>i</sub> 接收到请求消息 **REQUEST(i，sn)** 时，它将**RN<sub>j</sub>【I】**设置为**RN<sub>j</sub>【I】**和 **sn** 的最大值，即**RN<sub>j</sub>【I】**= max(**RN**
    *   更新**RN<sub>j</sub>【I】**后，站点 S <sub>j</sub> 将令牌发送到站点 S <sub>i</sub> 如果它有令牌并且**RN<sub>j</sub>【I】**=**LN【I】**+1
*   **执行临界区:**
    *   如果站点 S <sub>i</sub> 获得了令牌，它将执行关键部分。
*   **释放临界区:**
    执行完场地 S <sub>后，我</sub>退出临界区并执行以下操作:
    *   设置**LN【I】**=**RN<sub>I</sub>【I】**表示其临界区请求**RN<sub>I</sub>【I】**已执行
    *   对于 ID 不在令牌队列 **Q** 中的每个站点 S <sub>j</sub> ，如果**RN<sub>I</sub>【j】**=**LN【j】**+1 表示站点 S <sub>j</sub> 有未完成的请求，它会将其 ID 附加到 **Q** 中。
    *   经过上述更新后，如果队列 **Q** 非空，则从 **Q** 中弹出一个站点标识，并将令牌发送到弹出的标识所指示的站点。
    *   如果队列 **Q** 为空，则保留令牌

**消息复杂度:**
如果站点在关键部分请求时已经持有空闲令牌或者每个关键部分执行最多 N 条消息，则算法需要 0 条消息调用。这 N 条消息涉及

*   (N-1)条请求消息
*   1 封回复邮件

**铃木-卡萨米算法的缺点:**

*   **非对称算法:**站点保留令牌，即使它没有请求关键部分。根据对称算法
    的定义，“没有一个站点在没有被请求的情况下拥有访问其关键部分的权利。”

**表现:**T2】

*   同步延迟为 0，如果站点在其请求时持有空闲令牌，则不需要任何消息。
*   如果站点没有空闲令牌，最大同步延迟等于最大消息传输时间，每个关键部分调用最多需要 N 条消息。