# 为什么可执行文件依赖于操作系统

> 原文:[https://www . geesforgeks . org/why-可执行文件依赖于操作系统/](https://www.geeksforgeeks.org/why-executable-files-are-os-dependent/)

在本文中，我们将讨论为什么可执行文件依赖于操作系统，并将详细讨论原因。还将讨论提高兼容性的方法。我们一个一个来讨论。

**为什么可执行文件依赖于操作系统:**
执行可执行文件需要[操作系统](https://www.geeksforgeeks.org/operating-systems/)和中央处理器，如下所示。

*   中央处理器根据一个或多个指令集解码可执行文件中的二进制指令。x86(“32 位”)和 AMD64(“64 位”)指令集受到大多数消费类 CPU 的支持。可以为这些指令集之一编译程序，但不能两者都编译。这些指令集的扩展是可用的，可以在运行时检查对它们的支持。
*   SIMD 的支持就是这种扩张的一个例子。如果这些扩展存在，优化编译器可能会尝试利用它们，但它们通常也会提供一个没有它们也能工作的代码路径。
*   系统应用编程接口:程序可以使用必须安装在目标系统上的库。使用 Windows API 函数的软件不能在 Linux 上运行。在 Unix 世界中，中央操作系统 API 已经标准化为 POSIX:完全用 POSIX 函数编写的程序将在支持它们的任何 Unix 系统上运行，包括 Mac OS X 和 Solaris。
*   二进制格式:可执行文件必须遵循特定的二进制格式，以便操作系统正确加载、初始化和启动程序。可移植可执行文件格式在 Windows 上广泛使用，而 ELF 在 Linux 上广泛使用。

**结果:**
结果，如果两个系统具有相同的系统 API 和库，在相同的指令集上运行，并且利用相同的二进制格式，为其中一个编写的程序将在另一个上运行。

**但是，有一些方法可以提高兼容性:**
x86 可执行文件通常在 AMD64 指令集上运行。二进制格式指定应该使用哪种模式。操作系统必须付出额外的努力来处理 32 位和 64 位应用程序。一些二进制格式允许一个程序的多个副本存储在一个文件中，每个副本针对不同的指令集进行编码。苹果提倡使用“胖二进制文件”，因为它们从 Power-PC 架构过渡到 x86 架构。

*   有些程序被编译成中间形式，而不是机器代码。然后，这被动态地转化为实际的指令，或者可以被理解。这允许程序独立于其体系结构。在 UCSD p-系统上，利用了这种方法。
*   99%的现代视窗电脑都有 64 位中央处理器，它也可以执行 32 位软件。其余 1%使用 32 位处理器。因此，为 32 位 CPU 编写的软件被广泛使用。为 64 位处理器设计的软件可以在软件设计者关心的任何电脑上运行。

**注意–**
可执行文件包含的不仅仅是原始的机器代码。当操作系统加载它时，它会读取这个并决定它应该如何运行。编译时，通常指定一个目标 CPU 如果您不这样做，编译器将使用您当前的 CPU，并将其自身限制为只选择对您的 CPU 和它的旧版本通用的指令。如果你想使用一个奇特的新指令，它只在你的目标 CPU 的特定版本上可用，你可以告诉编译器，或者使用内部或内联汇编代码手动编码它。但是，如果您在不支持该指令的中央处理器上运行程序，它将崩溃。