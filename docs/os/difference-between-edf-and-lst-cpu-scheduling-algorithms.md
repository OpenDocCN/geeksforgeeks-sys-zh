# EDF 和 LST CPU 调度算法的区别

> 原文:[https://www . geesforgeks . org/difference-EDF-and-lst-CPU-scheduling-algorithms/](https://www.geeksforgeeks.org/difference-between-edf-and-lst-cpu-scheduling-algorithms/)

**1。[最早截止时间优先(EDF)](https://www.geeksforgeeks.org/earliest-deadline-first-edf-cpu-scheduling-algorithm/) :**
在最早截止时间优先调度算法中，在每个调度点，具有最短截止时间的任务被调度执行。它是一种用于实时系统的最优动态优先级驱动调度算法。它使用任务的优先级进行调度。在 EDF 中，任务的优先级是根据绝对截止日期分配的。截止时间最短的任务优先级最高。

**例–**
假设这里有两个过程 P1 和 P2。
设 p1 周期为 p1 = 50
设 P1 加工时间为 t1 = 25
设 p2 周期为 p2 = 75
设 P2 加工时间为 t2 = 30

**说明:**

1.  P1 的截止日期更早，所以 P1 优先于 P2。
2.  最初 P1 运行并完成了 25 次的执行。
3.  25 次之后，P2 开始执行，直到 50 次，P1 能够执行。
4.  现在，比较(P1，P2) = (100，75)的截止日期，P2 继续执行。
5.  P2 在时间 55 完成其处理。
6.  P1 开始执行，直到时间 75，当 P2 能够执行。
7.  现在，再次比较(P1，P2) = (100，150)的截止日期，P1 继续执行。
8.  重复以上步骤。
9.  最后，在时间 150，P1 和 P2 具有相同的截止日期，因此 P2 将继续执行，直到其处理时间，之后 P1 开始执行。

**2。[最小松弛时间(LST)](https://www.geeksforgeeks.org/least-slack-time-lst-scheduling-algorithm-in-real-time-systems/) :**
在最小松弛时间调度算法中，在每个调度点，首先执行松弛度最小的任务。它也是一种用于实时系统的动态优先级驱动调度算法。它根据任务的可宽延时间为系统中的所有任务分配一些优先级。松弛时间最少的任务获得最高优先级。

**示例–**
流程 P1:
到达时间=0，持续时间=10，截止时间=33
流程 P2:
到达时间=4，持续时间=3，截止时间=28
流程 P3:
到达时间=5，持续时间=10，截止时间=29

**说明:**

*   在时间 t=0:
    只有进程 P1 到达。
    执行 P1 直到时间 t=4。
*   在时间 t=4: P2 已经到达。
    P1 松弛时间:33-4-6 = 23
    P2 松弛时间:28-4-3=21
    因此 P2 开始执行直到时间 t = 5 到达。
*   在时间 t = 5:
    P1 松弛时间:33-5-6 = 22
    P2 松弛时间:28-5-2 = 21
    P3 松弛时间:29-5-10=12
    因此 P3 开始执行直到时间 t=13
*   在时间 t=13 时:
    P1 松弛时间:33-13-6 = 14
    P2 松弛时间:28-13-2 = 13
    P3 松弛时间:29-13-2=14
    因此 P2 开始执行直到时间 t=15
*   在时间 t = 15:
    P1 的松弛时间:33-15-6 = 12
    P3 的松弛时间:29-15-2=12
    因此 P3 开始执行直到时间 t=16
*   在时间 t = 16:
    P1 的松弛时间:33-16-6 = 11
    P3 的松弛时间:29-16-=12
    因此 P1 开始执行直到时间 t=18 等等。

**EDF 和 LST 调度算法的区别:**

<center>

| （EconomicDevelopmentFoundation）欧洲开发基金 | 当地标准时间(Local Standard Time) |
| --- | --- |
| 截止时间最短的任务被安排在第一个。 | 具有最小可宽延时间的任务首先被调度。 |
| 它根据任务的截止日期为任务分配优先级。 | 它根据任务的可宽延时间来分配任务。 |
| 它既可以用作静态调度，也可以用作动态调度。 | 它仅用作动态调度。 |
| 不需要任务的执行时间。 | 它需要任务的执行时间。 |
| 这是一种简单的优化算法。 | 这是一个复杂的算法。 |
| 它可以在任何一组任务上实现。 | 它只能在具有突发时间的任务集上实现。 |
| 它完全利用了中央处理器(甚至有时是 100%)。 | 它可能没有充分利用中央处理器。 |
| 它提高了处理器的效率和吞吐量。 | 它可能会降低处理器的效率和吞吐量。 |

</center>