# 操作系统中抢占内核和非抢占内核的区别

> 原文:[https://www . geeksforgeeks . org/抢先与不抢先操作系统内核的区别/](https://www.geeksforgeeks.org/difference-between-preemptive-and-non-preemptive-kernel-in-os/)

**1。抢先内核:**
抢先内核，顾名思义，是一种总是执行准备运行的最高优先级任务的内核类型。它不能使用不可重入的函数，除非函数是互斥的。

**示例:** Linux 2-6

**2。非抢占式内核:**
非抢占式内核，顾名思义，是一种内核数据结构上没有竞争条件的内核类型，因为一次内核中只有一个进程处于活动状态。它被认为是实时应用程序的一个严重缺陷，因为它不允许抢占在内核模式下运行的进程。

**示例:** Linux 2.4

**操作系统中抢先内核和非抢先内核的区别:**

<figure class="table">

| 

抢占内核

 | 

非抢先内核

 |
| --- | --- |
| 这是一个可能立即被取代的过程。 | 它是一个连续运行的过程，直到它完成处理执行处理器或自愿放弃中央处理器。 |
| 与非抢占内核相比，它更适合实时编程。 | 与抢占式内核相比，它不太适合实时编程。 |
| 在这种情况下，准备运行的优先级较高的任务被赋予 CPU 控制权。 | 在这种情况下，每个任务都明确放弃了中央处理器的控制。 |
| 即使在内核模式下，它通常也允许抢占。 | 它通常不允许内核模式下运行的进程抢占。 |
| 响应时间是确定性的，与非抢占式内核相比，响应速度更快。 | 响应时间是不确定的，与抢占式内核相比，响应速度更慢。 |
| 优先级较高的任务已就绪，当前正在运行的任务被挂起并移至就绪队列。 | 优先级较高的任务可能需要等待很长时间。 |
| 它不需要信号量。 | 共享数据通常需要信号量。 |
| 它不能使用不可重入的代码。 | 它可以使用不可重入的代码。 |
| 与非抢占式内核相比，设计抢占式内核更加困难。 | 与抢占式内核相比，设计非抢占式内核不太困难。 |
| 它们在现实场景中更安全、更有用。 | 它们不太安全，在现实场景中也不太有用。 |

</figure>