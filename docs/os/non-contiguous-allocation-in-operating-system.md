# 操作系统中的非连续分配

> 原文:[https://www . geesforgeks . org/非连续操作系统分配/](https://www.geeksforgeeks.org/non-contiguous-allocation-in-operating-system/)

先决条件–[变量分区](https://www.geeksforgeeks.org/variable-or-dynamic-partitioning-in-operating-system/)、[固定分区](https://www.geeksforgeeks.org/fixed-or-static-partitioning-in-operating-system/)、
T5】分页和[分段](https://www.geeksforgeeks.org/operating-systems-segmentation/)是允许进程的物理地址空间不连续的两种方式。它具有减少内存浪费的优势，但由于地址转换，它增加了开销。它会减慢内存的执行速度，因为地址转换会消耗时间。

在非连续分配中，操作系统需要为每个进程维护一个名为**页表**的表，该表包含进程在内存空间中获取的每个块的基址。在非连续内存分配中，进程的不同部分被分配到主内存的不同位置。允许跨越，这在动态或静态连续内存分配等其他技术中是不可能的。这就是为什么需要分页来确保有效的内存分配。分页是为了移除外部碎片。

**工作:**
在这里，一个进程可以以非连续的方式跨越主内存中的不同空间。假设进程 P 的大小为 4KB。考虑主内存有两个空插槽，每个大小为 2KB。因此，总可用空间为，2*2= 4 KB。在连续内存分配中，进程 P 不能被容纳，因为不允许跨越。

在连续分配中，内存中的空间应该分配给整个进程。如果没有，则该空间仍未分配。但是在非连续分配中，进程可以被分成不同的部分，从而填充主内存中的空间。在本例中，进程 P 可以分为大小相等的两部分–2KB。因此，进程 P 的一部分可以分配给主存储器的第一个 2KB 空间，而进程 P 的另一部分可以分配给主存储器的第二个 2KB 空间。下图将更好地解释:

![](img/2dd29877860c78142a8beb2759597c85.png)

但是，我们以什么方式划分一个进程来将它们分配到主内存中，这一点非常重要。在分析了主内存中的空白空间数量和大小后，对进程进行了划分。那么只有我们划分我们的过程。这是一个非常耗时的过程。由于主存储器中已经存在的进程的执行，它们的数量和大小每次都在变化。

为了避免这个耗时的过程，我们在到达主内存执行之前，提前将进程划分到辅助内存中。每个进程都被分成大小相等的不同部分，称为页面。我们还将我们的主内存分成大小相等的不同部分，称为帧。重要的是要理解:

```
Size of page in process 
= Size of frame in memory 

```

虽然它们的数量可能不同。下图将使您更好地理解:考虑每个帧大小为 2 KB 的空主内存，两个进程 P1 和 P2 各为 2 KB。

![](img/acfef3eb1d202761a7f70ae44c57414b.png)

预解主存储器，

![](img/a9f71c9e2ceb67d8e9418512c1267d7f.png)

总之，我们可以说，分页允许进程的内存地址空间是非连续的。分页更加灵活，因为只移动进程的页面。与连续内存分配相比，它允许更多的进程驻留在主内存中。