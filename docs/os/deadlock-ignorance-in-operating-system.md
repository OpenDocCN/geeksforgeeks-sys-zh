# 操作系统死锁无知

> 原文:[https://www . geesforgeks . org/死锁-操作系统无知/](https://www.geeksforgeeks.org/deadlock-ignorance-in-operating-system/)

如果集合中的每个进程都在等待一个只有集合中的另一个进程才能引起的事件，这种情况称为死锁。

假设进程 A 持有资源 C，进程 B 持有资源 D。
现在进程 A 请求资源 D，进程 B 请求资源 C，但是没有一个进程会得到这些资源，因为这两个资源都已经忙于其他进程，因此它们都不能继续进行。这种情况称为死锁。

有 [4 种情况导致死锁](https://www.geeksforgeeks.org/deadlock-prevention/)。它们如下

1.  互斥条件
2.  保持和等待状态
3.  无先占条件
4.  循环等待条件

要发生死锁，上述四个条件都应该存在。

**僵局无知:**
把头埋进沙子里，假装一点问题都没有，这种解决任何问题的方法叫做鸵鸟算法。解决任何问题的方法因人而异。

**全世界的科学家**都认为，处理死锁最有效的方法就是死锁预防。但是处理该系统的**工程师**认为，死锁预防应该得到更少的关注，因为死锁发生的机会非常少。

一周发生一次的系统故障、编译器错误、编程 bug、硬件崩溃应该得到更多的关注，而不是几年才发生一次的死锁问题。因此，大多数工程师在消除死锁方面并没有付出太多的代价。

许多操作系统遭受死锁的困扰，死锁甚至没有被检测到，然后被自动打破。作为解释，我们知道进程的数量是由进程表决定的。现在，正如我们所知，在进程表中只有有限数量的槽，因此当表已满时，分叉会失败。现在，当进程表中的槽为空时，新分叉的合理方法必须等待并重试。

此外，在打开和关闭文件时会注意到这样的问题。文件打开的最长时间受到限制，并在 i-node 表中提及，因此当表被填充时，会观察到类似的问题。另一个有限的资源是交换空间。事实上，操作系统中存储数据的所有表都有有限的资源限制。可能发生的情况是，一个 n 个进程的集合可能每个都声称占总数的 1/n，我们应该清除所有这些，然后每个都试图声称另一个吗？

包括 UNIX 和 WINDOWS，所有的操作系统都忽略死锁，首先假设用户被限制在一个进程中。**死锁无知**经常出现，因为通过这种方法死锁被免费消除，而不是花很多钱在其他死锁预防方法上，也给进程带来了一些不便的限制。因此，我们必须在解决死锁的不同方法之间的正确性和便利性之间做出决定。