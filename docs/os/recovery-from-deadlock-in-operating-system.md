# 从操作系统死锁中恢复

> 原文:[https://www . geesforgeks . org/从操作系统死锁中恢复/](https://www.geeksforgeeks.org/recovery-from-deadlock-in-operating-system/)

先决条件–[死锁检测和恢复](https://www.geeksforgeeks.org/deadlock-detection-recovery/)
当[死锁检测算法](https://www.geeksforgeeks.org/operating-system-deadlock-detection-algorithm/)确定系统中出现死锁时，系统必须从该死锁中恢复。打破[僵局](https://www.geeksforgeeks.org/operating-system-process-management-deadlock-introduction/)有两种方法:

**1。进程终止:**
为了消除死锁，我们可以简单地杀死一个或多个进程。为此，我们使用两种方法:

*   **(一)。中止所有陷入僵局的进程:**
    中止所有进程肯定会打破僵局，但代价很大。死锁的进程可能已经计算了很长时间，这些部分计算的结果必须被丢弃，并且有可能在以后重新计算它们。

*   **(b)。一次中止一个进程，直到死锁消除:**
    一次中止一个死锁进程，直到死锁循环从系统中消除。由于这种方法，可能会有相当大的开销，因为在中止每个进程后，我们必须运行死锁检测算法来检查是否有任何进程仍然死锁。

**2。资源抢占:**
为了使用资源抢占来消除死锁，我们从进程中抢占一些资源，并将这些资源交给其他进程。这种方法会引发三个问题–

*   **(一)。选择受害者:**
    我们必须确定哪些资源和哪些进程将被抢占，以及最小化成本的顺序。

*   **(b)。回滚:**
    我们必须确定应该如何处理资源被抢占的进程。一个简单的想法是完全回滚。这意味着中止进程并重新启动它。

*   **(c)。饥饿:**
    在一个系统中，可能会发生同样的过程总是被选为受害者。因此，该进程将永远无法完成其指定的任务。这种情况被称为**饥饿**，必须避免。一种解决方案是，一个进程只能被有限次地选为受害者。