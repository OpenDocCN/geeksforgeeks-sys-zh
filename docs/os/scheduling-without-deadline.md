# 无期限调度

> 原文:[https://www.geeksforgeeks.org/scheduling-without-deadline/](https://www.geeksforgeeks.org/scheduling-without-deadline/)

**什么是调度？**
调度是计算机科学领域的另一个热门问题。调度问题是为给定的请求有效地调度资源的问题。在操作系统中，通常计算机系统的单个处理器可能会遇到许多作业或用户程序。人们可以将调度问题可视化为作业的最优排序，使得作业周转时间最小化。简而言之，目标是以最佳顺序安排作业，以便更快地执行作业。

> **让我们想象一下日程安排的场景:**
> 在一个图书馆里，只有一个图书管理员被分配当天的问题，有几个学生在排队登记他们的书籍问题，所以图书管理员想到了一个问题，让它稍微重新排序，这可能有助于满足所有学生，并减少发行时间。那么在这种情况下，什么是最佳顺序呢？
> 
> 很明显，队列中书籍数量较少的学生比书籍数量较多的学生花在一个问题上的时间更少。用更少的书来处理学生是有意义的，这样可以最大限度地减少学生的集体等待时间。

**无期限作业调度:**
那么，什么是无期限作业调度？

*   调度问题的目标是调度任务，从而获得最大的总利润。
*   考虑调度的作业没有截止日期，即没有任何执行时间上限的作业。
*   这种工作安排的目的是盈利，但没有任务的最后期限。

**为了理解这个概念，我们举个例子。**
我们假设与调度相关的作业没有截止日期，即作业没有任何执行时间上限。试图用贪婪的方法解决它；
假设服务时间与以下三个任务相关联:

*   t <sub>1</sub> =2
*   t <sub>2</sub> =7
*   t <sub>3</sub> =4

为了安排这些任务，让我们首先通过列出下表中所有可能的顺序来找到最佳顺序。由于有三个任务，任务可以在 3！路，等于 6。一般来说，对于 N 个工作，就会有 N 个！可能的订单。

*   为了说明这一点，让我们举一个组合，比如[1，2，3]。如果首先安排作业 1，那么根据给定的问题，作业 1 需要 2 个时间单位。既然这是第一份工作，就没有浪费时间。
*   在此期间，作业 2 必须等待，因为只有一个处理器。因此，作业 2 需要 2(等待时间)+ 7(处理时间)，等于 9。在此之前，作业 3 必须等待。
*   作业 3 的等待时间为(2 + 7)，需要 4 个时间单位才能完成。因此，作业 3 在系统中花费的总时间是 9(等待时间)，4 是(处理时间)。

<figure class="table">

| 

日程安排

 | 

系统中的总时间

 | 

平均时间

 |
| --- | --- | --- |
| [1, 2, 3] | 2 + (2 + 7 ) + ( 2 + 7 + 4 ) = 24 | eight |
| [1, 3, 2] | 2 + (2 + 4 ) + ( 2 + 4 + 7 ) = 21 | seven |
| [2, 1, 3] | 7 + (7 + 2 ) + ( 7 + 2 + 4 ) = 29 | Nine point six |
| [2, 3, 1] | 7 + (7 + 4 ) + ( 7 + 4 + 2 ) = 31 | Ten point three |
| [3, 1, 2] | 4 + (4 + 2 ) + ( 4 + 2 + 7 ) = 23 | Seven point nine |
| [3, 2, 1] | 4 + (4 + 7 ) + ( 4 + 7 + 2 ) = 28 | Nine point three |

</figure>

作业的平均时间是通过将系统中的总时间除以作业数量获得的，即 24/3=8。
剩余作业的计算如上表所示。

*   可以观察到，系统中的最小总时间为 21，周转时间为 7。
*   这对应于顺序[1，3，2]。因此，这是最佳顺序。
*   还可以注意到，任务以服务时间的升序排列，即{2，4，7}，这由此说明了“最短作业优先调度”的原理，即在调度较长的作业之前首先调度最短的作业。
*   一旦确定了这个原则，就可以有效地编写贪婪算法。

**这个问题非正式的贪婪算法可以写成如下:**

**步骤 1–**按服务时间以非递减顺序对作业进行排序。
**第 2 步–**安排已排序作业列表的下一个作业。将此包括在解决方案集中。
**步骤 3–**如果排序作业列表的所有实例都已解决，则返回解决方案集。

形式算法如下:
**输入–**一组作业 1 到 n 的数组 J 以及服务时间
**输出–**一个最优调度

```
Begin
    S = {sorted array of jobs in J based on service time }
    i = 1
    Schedule = ∅
    while (i < = n ) do                 //for all jobs do
        select the next job i from S    //Selection procedure selects from sorted list
        solution = schedule U jobs i
        i = i+1

    End while
    return(Solution)
End
```

*   *算法首先对作业进行排序，然后贪婪地逐个选择作业，并调度到服务器。*
*   *可以观察到，由于不涉及截止日期，所有作业都可以为服务器调度。*

**复杂度分析:**
可以观察到，前述调度算法的核心原理是*对任务的排序*。
排序的复杂度为 O(n log n)时间。该调度算法的所有剩余任务只需要 O(n)个时间。
因此，调度算法的合成复杂度为 *max{n log n，n } = **n log n time*** **。**