# 操作系统中的多处理器调度

> 原文:[https://www . geesforgeks . org/多处理器操作系统调度/](https://www.geeksforgeeks.org/multiple-processor-scheduling-in-operating-system/)

在多处理器调度中**多个中央处理器**可用，因此**负载共享**成为可能。然而，与单处理器调度相比，多处理器调度更加复杂**。在多处理器调度中，有时处理器是相同的，即同质的，就其功能而言，我们可以使用任何可用的处理器来运行队列中的任何进程。**

### **多处理器调度方法–**

**一种方法是，当所有的调度决策和输入/输出处理都由称为**主服务器**的单个处理器处理，而其他处理器只执行**用户代码**时。这很简单，减少了数据共享的需要。这整个场景被称为**非对称多处理**。**

**第二种方法使用**对称多处理**，其中每个处理器都是**自调度**。所有进程可能都在一个公共就绪队列中，或者每个处理器可能都有自己的就绪进程专用队列。通过让每个处理器的调度器检查就绪队列并选择要执行的进程，调度进一步进行。**

### **处理器相似性–**

**处理器关联性是指一个进程与它当前运行的处理器具有**关联性**。
当一个进程在特定的处理器上运行时，会对高速缓冲存储器产生一定的影响。进程最近访问的数据填充处理器的高速缓存，因此，进程连续的存储器访问通常在高速缓存中得到满足。现在，如果进程迁移到另一个处理器，则第一个处理器的高速缓冲存储器的内容必须无效，第二个处理器的高速缓冲存储器必须重新填充。由于无效和重新填充高速缓存的高成本，大多数 SMP(对称多处理)系统试图避免进程从一个处理器迁移到另一个处理器，并试图保持一个进程在同一处理器上运行。这就是所谓的**处理器亲和力**。**

**处理器关联性有两种类型:**

1.  ****软相似性–**当操作系统有一个策略，试图让一个进程在同一个处理器上运行，但不保证它会这样做，这种情况被称为软相似性。**
2.  ****硬关联–**硬关联允许进程指定它可能运行的处理器子集。有些系统如 Linux 实现了软亲和，但也提供了一些支持硬亲和的系统调用如 *sched_setaffinity()* 。**

### **负载平衡–**

**负载平衡是**现象**，它将**工作负载**均匀地**分布在一个 SMP 系统中的所有处理器上。只有在每个处理器都有自己的专用进程队列的系统上，负载平衡才是必要的。负载平衡是不必要的，因为一旦处理器空闲，它会立即从公共运行队列中提取一个可运行的进程。在 SMP(对称多处理)上，重要的是保持所有处理器之间的工作负载平衡，以充分利用拥有多个处理器的优势，否则一个或多个处理器将处于空闲状态，而其他处理器具有高工作负载以及等待 CPU 的处理器列表。****

**有两种通用的负载平衡方法:**

1.  ****推送迁移–**在推送迁移中，任务会定期检查每个处理器上的负载，如果发现不平衡，它会通过将进程从过载的处理器移动到空闲或不太忙的处理器来平均分配每个处理器上的负载。**
2.  ****Pull Migration–**Pull Migration 发生在空闲处理器从繁忙处理器中拉出等待执行的任务时。**

### **多核处理器–**

**在多核处理器**中，多个处理器**内核被放置在同一个物理芯片上。每个内核都有一个寄存器集来维护其体系结构状态，因此在操作系统看来，它是一个独立的物理处理器。**使用多核处理器的 SMP 系统**比每个处理器都有自己的物理芯片的系统更快，消耗的能量也更少**。****

****然而多核处理器可能会使调度问题复杂化。当处理器访问内存时，它会花费大量时间等待数据变得可用。这种情况被称为**记忆停滞**。出现这种情况有多种原因，例如高速缓存未命中，即访问不在高速缓存中的数据。在这种情况下，处理器可能会花费高达 50%的时间等待数据从内存中变得可用。为了解决这个问题，最近的硬件设计已经实现了多线程处理器内核，其中两个或多个硬件线程被分配给每个内核。因此，如果一个线程在等待内存时停止，内核可以切换到另一个线程。****

****多线程处理处理器有两种方法:****

1.  ******粗粒度多线程–**在粗粒度多线程中，一个线程在一个处理器上执行，直到一个长延迟事件(如内存停滞)发生，由于长延迟事件导致的延迟，处理器必须切换到另一个线程才能开始执行。线程间切换的成本很高，因为在另一个线程开始在处理器内核上执行之前，必须终止指令流水线。一旦这个新线程开始执行，它就开始用它的指令填充流水线。****
2.  ******细粒度多线程–**这种多线程主要在指令周期的边界以更精细的级别在线程之间切换。细粒度系统的架构设计包括线程切换逻辑，因此线程间切换的成本很低。****

### ****虚拟化和线程化–****

****在这种类型的**多处理器**调度中，即使是单个中央处理器系统也像多处理器系统一样。在具有虚拟化的系统中，虚拟化向系统上运行的每个虚拟机呈现一个或多个虚拟 CPU，然后在虚拟机之间调度物理 CPU 的使用。大多数虚拟化环境都有一个主机操作系统和许多来宾操作系统。主机操作系统创建并管理虚拟机。每个虚拟机都安装了客户操作系统，并且应用程序在该客户中运行。每个客户操作系统可以被分配给特定的用例、应用程序或用户，包括分时甚至实时操作。任何假定在给定时间内有一定进度的客户操作系统调度算法都将受到虚拟化的负面影响。分时操作系统试图为每个时间片分配 100 毫秒，以给用户一个合理的响应时间。给定的 100 毫秒时间片可能需要比 100 毫秒多得多的虚拟 CPU 时间。根据系统的繁忙程度，时间片可能需要一秒或更长时间，这将导致登录到该虚拟机的用户的响应时间非常短。这种调度分层的净效果是，单个虚拟化操作系统仅接收一部分可用的 CPU 周期，即使它们认为它们正在接收所有周期，并且正在调度所有这些周期。通常，虚拟机中的时间时钟是不正确的，因为计时器触发的时间不会比专用 CPU 长。****

******虚拟化**因此可以取消虚拟机内操作系统的良好调度算法努力。****

******参考–**
[操作系统原理–](https://www.amazon.in/Operating-System-Principles-Silberschatz/dp/8126509627)高尔文****