# 处理死锁

> 原文:[https://www.geeksforgeeks.org/handling-deadlocks/](https://www.geeksforgeeks.org/handling-deadlocks/)

**死锁**是一个进程或一组进程被阻塞的情况，等待由某个其他等待进程持有的其他资源。这是系统的不良状态。以下是发生死锁必须同时具备的[四个条件](https://www.geeksforgeeks.org/conditions-for-deadlock-in-operating-system/)。

1.  **互斥–**
    一个资源一次只能被一个进程使用。如果另一个进程请求该资源，那么请求进程必须被延迟，直到该资源被释放。
2.  **保持并等待–**
    一些进程必须在不可共享模式下保持一些资源，同时必须等待获取一些更多的资源，这些资源当前由不可共享模式下的其他进程保持。
3.  **无先发制人–**
    授予流程的资源只能在流程完成任务后，作为该流程自愿行动的结果释放回系统。
4.  **循环等待–**
    死锁进程包含在循环链中，这样每个进程都拥有一个或多个被链中下一个进程请求的资源。

**处理死锁的方法:**
处理死锁有三种方法。

```
1. Deadlock Prevention
2. Deadlock avoidance
3. Deadlock detection 
```

这些解释如下。

**1。[死锁预防](https://www.geeksforgeeks.org/deadlock-prevention/) :**
死锁预防的策略是以排除死锁可能性的方式设计系统。间接法防止死锁三个必要条件之一的发生，即互斥、无先占和保持等待。直接方法防止循环等待的发生。

**防护技术–**
**互斥–**受操作系统支持。

**保持和等待–**可以通过要求一个进程一次请求其所有所需资源，并阻止该进程，直到其所有请求可以同时被批准，来防止这种情况。但是这种预防没有产生好的结果，因为:

*   需要很长的等待时间*   在有效使用分配的资源时*   A process may not know all the required resources in advance

    **无先发制人–**用于“无先发制人”的技术

    *   如果持有某个资源的进程请求另一个不能立即分配给它的资源，则释放当前持有的所有资源，并且如果需要，将它们与附加资源一起再次请求。
    *   如果一个进程请求当前由另一个进程持有的资源，操作系统可能会先发制人，要求第二个进程释放其资源。只有当两个进程的优先级不同时，这种方法才有效。

    循环等待确保此条件永远不成立的一种方法是对所有资源类型进行总排序，并要求每个进程以递增的枚举顺序请求资源，即，如果一个进程已被分配了类型为 R 的资源，则它随后可能只请求排序中跟随 R 的那些类型的资源。

    **2。[避免死锁](https://www.geeksforgeeks.org/deadlock-prevention/) :**
    这种方法允许死锁的三个必要条件，但做出明智的选择以确保永远不会达到死锁点。它允许比避免检测更多的并发性
    动态地决定当前的资源分配请求如果被批准是否会潜在地导致死锁。它需要了解未来的流程请求。避免死锁的两种技术:

    1.  进程启动拒绝
    2.  拒绝资源分配

    **死锁避免技术的优势:**

    *   不必预先阻止和回滚进程
    *   比死锁预防限制更少

    **缺点:**

    *   必须事先知道未来的资源需求
    *   进程可能会被长时间阻塞
    *   存在固定数量的资源进行分配

    **3。[死锁检测](https://www.geeksforgeeks.org/deadlock-detection-recovery/) :**
    死锁检测通过使用和算法来跟踪循环等待并杀死一个或多个进程，从而消除死锁。定期检查系统状态，以确定一组进程是否死锁。死锁是通过中止和重新启动一个进程，放弃该进程所拥有的所有资源来解决的。

    *   这种技术不限制资源访问或进程操作。
    *   尽可能将请求的资源授予进程。
    *   它从不延迟流程启动，并方便在线处理。
    *   缺点是固有的先发制人损失。