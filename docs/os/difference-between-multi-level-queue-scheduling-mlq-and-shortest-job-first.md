# 多级队列调度(MLQ)和最短作业优先

的区别

> 原文:[https://www . geeksforgeeks . org/区别-多级-队列-调度-mlq-和-最短-作业优先/](https://www.geeksforgeeks.org/difference-between-multi-level-queue-scheduling-mlq-and-shortest-job-first/)

**1。[多级队列调度(MLQ)](https://www.google.com/amp/s/www.geeksforgeeks.org/multilevel-queue-mlq-cpu-scheduling/amp/) :**
只有一个队列并调度所有进程是相当困难的。这是使用多级队列调度的地方。在这种情况下，根据进程的属性，如系统进程、输入输出进程等，进程被分为不同的类别。因此，我们得到了 n 类进程的“n”个队列。每个队列都被分配了优先级，并且可以使用自己的调度算法，这使得同时使用许多调度算法变得方便。一般来说，队列的最高层具有最高优先级，当我们移动到较低层时，优先级会降低。如果上层相对于下层具有绝对优先权，那么它是不可抢占的，否则如果时间片被划分在不同的队列中，那么它在本质上变成可抢占的。

*   **优势–**
    这个算法的主要优势是我们可以使用各种算法，比如 FCFS、SSJF、LJF 等。同时在不同的队列中。
*   **缺点–**
    最底层的进程存在饥饿问题。

**2。[最短作业优先(SJF)](https://www.geeksforgeeks.org/program-for-shortest-job-first-or-sjf-cpu-scheduling-set-1-non-preemptive/) :**
是基于流程的爆发时间。进程根据其突发时间被放入就绪队列。该算法首先处理突发时间最少的进程。仅比较那些在该时间之前存在或已经到达的进程的突发时间。它本质上也是非先发制人的。其抢先版称为[最短剩余时间优先(SRTF)算法](https://www.geeksforgeeks.org/introduction-of-shortest-remaining-time-first-srtf-algorithm/)。

该算法的主要优点是，它为给定的一组进程提供了最小的等待时间，从而减少了平均等待时间。这种算法的缺点是长进程可能永远不会被系统处理，并且可能在队列中停留很长时间，导致进程饥饿。

**注意–**
如果两个进程具有相同的突发时间，则使用 FCFS 断开连接，即先到达的进程先被处理。

**SJF 和多级队列调度的区别:**

<center>

| 最短工作优先(SJF) | 多级队列调度(MLQ) |
| --- | --- |
| SJF 也是非抢占式的，但它的抢占式版本也被称为最短剩余时间优先(SRTF)算法。 | MLQ 可以不先发制人，也可以根据情况先发制人。 |
| 它按照突发时间的降序执行进程，即最先执行最短的作业。 | 进程的执行取决于该进程所属的特定队列级别的优先级。进程的进一步选择是基于特定队列中使用的算法类型。 |
| SJF 的开销是由于必须记录过去的时间。 | MLQ 有一些 CPU 开销，因为它需要在队列之间切换。 |
| 就 SJF 而言，平均等待时间最短。 | 平均等待时间取决于各级队列中使用的算法。 |
| 其实现的主要困难是下一个 CPU 突发的长度未知。 | 算法复杂，实现困难。 |
| 它导致具有非常大的爆发时间的进程的饥饿。 | 它会导致较低层次的进程饥饿。 |

</center>