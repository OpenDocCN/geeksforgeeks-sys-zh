# 分布式系统中的互斥

> 原文:[https://www . geesforgeks . org/分布式系统互斥/](https://www.geeksforgeeks.org/mutual-exclusion-in-distributed-system/)

**互斥**是一个并发控制属性，引入它是为了防止竞争条件。它要求当另一个并发进程当前存在或正在其关键部分执行时，一个进程不能进入其关键部分，即在任何给定的时间实例中，只允许一个进程执行该关键部分。

**单机系统与分布式系统互斥:**
在单机系统中，内存等资源在不同进程间共享。共享资源的状态和用户的状态在共享内存中很容易获得，因此借助共享变量(例如:[信号量](https://www.geeksforgeeks.org/semaphores-operating-system/))可以很容易地解决互斥问题。

在分布式系统中，我们既没有共享内存，也没有公共物理时钟，因此我们无法使用共享变量来解决互斥问题。为了消除分布式系统中的互斥问题，采用了基于消息传递的方法。

由于缺少共享内存和公共物理时钟，分布式系统中的站点没有完整的系统状态信息。

**互斥算法要求:**

*   **无死锁:**
    两个或更多站点不应该无休止地等待任何永远不会到达的消息。
*   **无饥饿:**
    每个想要执行关键部分的站点都应该有机会在有限的时间内执行。当其他站点重复执行关键部分时，任何站点都不应该无限期地等待执行关键部分
*   **公平:**
    每个站点都应该有公平的机会执行关键部分。任何执行关键部分的请求都必须按其发出的顺序执行，即关键部分执行请求应按其到达系统的顺序执行。
*   **容错:**
    如果出现故障，它应该能够自己识别，以便在没有任何中断的情况下继续运行。

**分布式互斥的解决方案:**
众所周知，在分布式系统中，共享变量或局部内核不能用来实现互斥。消息传递是实现互斥的一种方式。下面是基于消息传递在分布式系统中实现互斥的三种方法:

1.  **基于令牌的算法:**
    *   唯一的**令牌**在所有站点之间共享。
    *   如果一个站点拥有唯一的令牌，则允许它进入其关键部分
    *   这种方法使用序号为关键部分订购请求。
    *   每个关键部分的请求都包含一个序列号。该序列号用于区分旧请求和当前请求。
    *   这种方法确保了互斥，因为令牌是唯一的
    *   ```
        Example: 
        Suzuki-Kasami’s Broadcast Algorithm
        ```

2.  **基于非令牌的方法:**
    *   一个站点与其他站点通信，以确定哪些站点接下来应该执行关键部分。这需要在站点之间交换两轮或更多轮连续的消息。
    *   这种方法使用时间戳而不是序列号来为关键部分的请求排序。
    *   当一个站点请求关键部分时，它会得到一个时间戳。时间戳还用于解决关键部分请求之间的任何冲突。
    *   所有遵循非令牌方法的算法都保持一个逻辑时钟。逻辑时钟根据兰波特的方案进行更新
    *   ```
        Example: 
        Lamport's algorithm, Ricart–Agrawala algorithm
        ```

3.  **基于法定人数的方法:**
    *   每个站点只请求一个称为**法定人数**的站点子集，而不是从所有其他站点请求执行关键部分的许可。
    *   站点或仲裁的任何两个子集包含一个公共站点。
    *   该公共站点负责确保互斥
    *   ```
        Example: 
        Maekawa’s Algorithm
        ```