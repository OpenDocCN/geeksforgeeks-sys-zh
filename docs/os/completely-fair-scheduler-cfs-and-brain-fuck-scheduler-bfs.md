# 完全公平调度器(CFS)和脑残调度器(BFS)

> 原文:[https://www . geeksforgeeks . org/complete-fair-scheduler-CFS-and-brain-操-scheduler-bfs/](https://www.geeksforgeeks.org/completely-fair-scheduler-cfs-and-brain-fuck-scheduler-bfs/)

先决条件–[CPU 调度](https://www.geeksforgeeks.org/cpu-scheduling-in-operating-systems/)
完全公平调度器(CFS)和脑残调度器(BFS)是目前 Linux 中使用的两种不同的进程调度器。

**进程调度–**
由于任何程序都是作为进程加载到 ram 中，然后 CPU 根据进程的优先级执行进程。

**1。完全公平调度程序(CFS) :**

*   它是基于旋转楼梯截止时间表(RSDL)。
*   这是自 2.6.23 版以来的默认计划流程。
*   对输入输出和中央处理器绑定进程的优雅处理。

顾名思义，它在所有进程之间公平或均等地分配 CPU 时间。在了解 CFS 之前，我们先来看看 N 个流程的*理想公平调度(IFS)* 。如果就绪队列中有 N 个进程，那么根据 IFS，每个进程将获得(100/N)%的 CPU 时间。

让我们用如下所示的四个进程及其突发时间在就绪队列中等待执行。

<figure class="table">

| 过程 | 突发时间(毫秒) |
| --- | --- |
| A | Ten |
| B | six |
| C | Fourteen |
| D | six |

取 4 毫秒的时间量。最初，有四个进程在就绪队列中等待执行，根据理想的公平调度，每个进程为其执行获得同等公平的时间(时间量/N)。

所以 4/4=1 每个进程在第一个量程中有 1 毫秒的执行时间。六个量子过程完成后，B 和 D 被完全执行，剩下的是 A 和 C，它们已经执行了 6 毫秒，剩余时间是 A = 4 毫秒和 C = 8 毫秒)。

在第七个时间段，A 和 C 将执行(4/2 = 2 毫秒，因为只剩下两个进程)。这是一种理想的公平调度，在这种调度中，无论优先级如何，每个进程都获得相等的时间量份额。

以下是国际单项体育联合会的表格说明。
Q:表示 4 毫秒的时间量。

<figure class="table">

| 过程 | 雌三醇环戊醚 | Q2 | Q3 | Q4 | Q5 | Q6 | Q7 | Q8 | Q9 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| A | one | one | one | one | one | one | Two | Two | – |
| B | one | one | one | one | one | one | – | – | – |
| C | one | one | one | one | one | one | Two | Two | four |
| D | one | one | one | one | one | one | – | – | – |

CFS 类似于基于理想的调度，而是根据虚拟可运行时间对每个进程进行优先级排序。

**CFS 背后的理念–**

*   在印刷电路板(过程控制块)中，每个可运行的过程都有一个与之相关联的虚拟时间。
*   每当上下文切换发生时(或在每个调度点)，当前运行的进程虚拟时间增加 virtual runtime _ curr process+= T .
    其中 T 是最近执行的时间。
*   因此，进程的运行时间单调增加。

所以最初每个进程都有一些开始虚拟时间(你可以谷歌一下最初虚拟运行时间是如何计算的)。

CFS 是一种非常简单的进程调度算法，它是使用红黑树而不是队列来实现的。
所以主内存中的所有进程都被插入到红黑树中，每当一个新的进程出现时，它就被插入到树中。正如我们所知，红黑树是自我平衡的二分搜索法树。

在 C++中，我们可以在 STL 中使用映射，因为它们是使用红黑树实现的。

现在只要有**上下文切换**发生–

*   如上所述，正在执行的当前进程的虚拟时间被更新。
*   新的进程决定了哪个虚拟时间最少，我们知道哪个是红黑树最左边的节点。
*   如果当前进程仍有一些突发时间，则将其插入红黑树。

这样一来，每个进程都有公平的执行时间，因为在每次上下文切换之后，进程的虚拟时间会增加，因此优先级也会改变。

**CFS 的时间复杂性分析–**

1.  插入红色和黑色的树需要 0(logn)。
2.  找到虚拟时间最短的节点是 O(1)，因为我们可以维护一个指针。(在地图中，我们可以使用 auto it=map.begin())。

```
So overall time complexity is O(logn) 
```

这里红黑树是一次创建，然后我们有一个 N 进程的红黑树，所以调度时间复杂度是 O(logn)。

使用红黑树还有一个好处，那就是如果一个进程受输入/输出限制，那么它的虚拟时间将会非常少，并且它将作为红黑树中最左边的节点出现，因此首先执行。因此，CFS 很容易找出哪些进程是输入输出绑定的，哪些是中央处理器绑定的，并且它赋予输入输出绑定的进程更高的优先级，从而避免了饥饿。

**2。大脑操调度器(BFS) :**
与 CFS 调度器不同，BFS 是 O(n)调度器，它使用像队列一样对待的双链表。
因此，在最坏的情况下，在上下文切换时选择新的进程可以变成 0(n)，并且当使用队列时，进程的插入是 0(1)。

使用全局运行队列，以便所有的中央处理器都可以访问它。在上下文切换期间，会扫描队列，直到找到优先级最高的最佳进程，然后再执行。优先级是根据每个进程的虚拟截止时间公式决定的，并相应地执行。

由于上下文切换开销和时间复杂性，它在 Linux 中不再使用。

</figure>

</figure>