# 操作系统内存管理的最佳方式

> 原文:[https://www . geesforgeks . org/最佳操作系统内存管理方式/](https://www.geeksforgeeks.org/best-ways-for-operating-system-memory-management/)

**先决条件–**[分区分配方法](https://www.geeksforgeeks.org/partition-allocation-methods-in-memory-management/)

[**【连续内存分配】**](https://www.geeksforgeeks.org/implementation-of-contiguous-memory-management-techniques/) **:**
对于内存部分来说，最简单的方法可能是将内存隔离到几个固定的分区中。每个分区恰好包含一个进程。多程序设计的水平取决于分区的数量。在不同的分区技术中，当一个分区空闲时，进程从信息行中选择，并堆叠到空闲的内存分区中。当一个进程结束时，内存分区为另一个进程打开。批处理操作系统利用固定大小的分区共谋。

操作系统保存了一个表格，展示了哪一块内存是空闲的并被占用。当流程进入框架时，它将被堆叠到信息行中。操作系统监控每个进程的内存先决条件和可访问内存的大小，并计算出哪个进程也要指定内存。当一个进程需要时，操作系统会为这个进程寻找一个巨大的洞，这个洞是一个巨大的可访问的自由内存的正方形。如果洞太大，它就分成两部分。一部分被分配到所述过程，另一部分回到孔的排列。观察孔的排列，找出哪个孔最适合分配。选择自由洞有三种方法:

**第一位**–
分配足够大的主孔。该算法从一开始就检查内存，并选择最容易访问的足够大的正方形来容纳进程。

**最佳位**–
它选择的孔，即尺寸最接近招标。它分配最小的洞，也就是说，足够大来容纳进程。

**最差配合**–
它选择的孔，即尺寸最接近招标。它分配最小的洞，也就是说，足够大来容纳进程。

**操作系统:**
首先，拟合和最佳拟合是最主流的动态内存指定算法。第一次试衣总的来说要快一些。最适合的是寻找整个纲要来定位最小的洞，即足够大的洞。最差的匹配会降低最小孔的创建速度。这些算法中的每一个都经历了碎片化的不良影响。

**内存保护:**
内存保护是指保护操作系统不受用户进程的影响，同时保护进程不受其他进程的影响。存储器保护是通过使用带有断点寄存器的重新定位寄存器来实现的。重新定位寄存器包含最小实际地址的值，截断点寄存器包含逻辑地址的范围。

(重新定位= 100040，极限= 74600)。逻辑地址不应该正好是断点寄存器；MMU 通过在重定位寄存器中添加激励来动态映射逻辑地址。当中央处理器调度器选择一个进程执行时，调度器将带有正确值的重定位和切断寄存器作为设置开关的一部分进行堆叠。由于中央处理器创建的每个地址都要与这些寄存器进行核对，因此我们可以保护操作系统和其他用户的程序和数据不被篡改。

[**【碎片化】**](https://www.geeksforgeeks.org/difference-between-internal-and-external-fragmentation/) **:**
内存碎片可以有两种——内部碎片化和外部碎片化。在内部碎片化中，段内有浪费的空间，因为堆叠的数据的平方比分区更小。示例–如果有一个 50kb 的正方形，并且该进程请求 40kb，并且该正方形极有可能被分配给该进程，此时将剩下 10kb 的内存。

当有足够的内存空间来满足请求时，外部碎片就存在了，然而，它并不相邻，即堆存被分成大量的小孔。外部碎片化可能是个小问题，也可能是个大问题。击败外部碎片的一个答案是压缩。目标是将所有空闲内存移动到一起，形成一个巨大的正方形。压实始终超出想象的范围。如果重新定位是静态的，并且是在加载时完成的，那么压缩就超出了想象的范围。对于外部碎片问题的另一个可能的答案是允许进程的逻辑地址空间是非邻接的，以这种方式允许进程在最后一个可访问的点分配实际内存。

[](https://www.geeksforgeeks.org/segmentation-in-operating-system/)****:**
大多数用户不认为内存是一个直接的字节数组，相反，用户认为内存是一个 55 大小不等的段，用于特定的用途。示例–代码、数据、堆栈、堆等等。逻辑地址是各种各样的段。地址决定了段名和段内的偏移量。用户通过使用两个量来指示地址:段名和偏移量。为了省事，用段号对段进行编号和引用。所以逻辑地址包括<段号，偏移量>。**