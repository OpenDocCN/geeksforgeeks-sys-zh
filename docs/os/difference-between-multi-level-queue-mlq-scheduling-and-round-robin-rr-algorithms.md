# 多级队列(MLQ)调度和循环调度算法的区别

> 原文:[https://www . geesforgeks . org/多级队列差异-mlq-调度和循环调度-RR-算法/](https://www.geeksforgeeks.org/difference-between-multi-level-queue-mlq-scheduling-and-round-robin-rr-algorithms/)

**1。** [**【多级队列调度(MLQ)**](https://www.google.com/amp/s/www.geeksforgeeks.org/multilevel-queue-mlq-cpu-scheduling/amp/) **:**
仅仅拥有一个队列并调度所有进程是相当困难的。这是使用多级队列调度的地方。在这种情况下，根据进程的属性，如系统进程、输入/输出进程等，进程被分为不同的类别。因此，我们得到了 n 类进程的“n”个队列。每个队列都被分配了优先级，并且可以使用自己的调度算法，这使得同时使用许多调度算法变得方便。一般来说，队列的最顶层具有最高优先级，当我们移动到较低的级别时，优先级会降低。如果上层具有相对于下层的绝对优先权，那么它是不可抢占的，否则如果时间片被划分在不同的队列中，那么它在本质上变成可抢占的。

*   **优势:**
    这个算法的主要优势是我们可以使用各种算法，比如 FCFS、SSJF、LJF 等。同时在不同的队列中。

*   **缺点:**
    最底层的进程存在饥饿问题。

**2。**[](https://www.geeksforgeeks.org/program-round-robin-scheduling-set-1/)****:**
它是专门为分时系统设计的。进程被放入就绪队列，在这种情况下是一个循环队列。在这种情况下，定义了一个称为时间量子的小时间单位。该算法从队列中选择第一个进程，并在时间段定义的时间内执行它。如果进程的突发时间小于时间量，则中央处理器执行下一个进程，但是如果它的突发时间高于时间量，则该进程被中断，并且为相同的时间量执行下一个进程。如果一个进程被中断，那么就会发生一个上下文切换，并且这个进程会被放回队列的尾部。本质上是先发制人。**

**该算法主要依赖于时间量子。非常大的时间量使得 RR 与 FCFS 相同，而非常小的时间量将导致开销，因为上下文切换将在非常小的间隔后一次又一次地发生。**

**这种算法的主要优点是所有进程一个接一个地执行，不会导致进程饥饿或等待相当长的时间才能执行。**

****MLQ 和循环调度算法的区别:****

<figure class="table">

| MLQ | 循环赛 |
| --- | --- |
| 如果进程所在的队列级别和进一步的执行取决于该级别中使用的算法，则 MLQ 根据优先级执行该进程。 | 循环调度根据定义的时间量执行进程，即每个进程执行固定的时间量。 |
| 根据具体情况，MLQ 可以先发制人，也可以不先发制人。 | 循环赛本质上是先发制人的。 |
| 给定进程集的平均等待时间取决于在多级队列的不同级别中使用的算法元组。 | 给定进程集的平均等待时间非常短，并且取决于时间量。 |
| 它相当复杂，很难实现。 | 实现 RR 相当容易。 |
| 这导致了较低层次的进程的匮乏。 | 每个进程都被执行，每个用户都觉得自己的工作正在完成，因为中央处理器给了每个进程相等的时间。 |
| 不同级别之间的切换会导致处理器开销。 | 在 RR 的情况下，如果时间量非常小，那么在非常短的时间间隔之后，上下文切换会一次又一次地发生，这导致开销。 |

</figure>