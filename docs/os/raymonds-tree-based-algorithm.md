# 基于雷蒙德树的算法

> 原文:[https://www . geeksforgeeks . org/raymonds-基于树的算法/](https://www.geeksforgeeks.org/raymonds-tree-based-algorithm/)

先决条件–[分布式系统中的互斥](https://www.geeksforgeeks.org/operating-system-mutual-exclusion-in-distributed-system/)
**雷蒙德的基于树的算法**是分布式系统中互斥的基于锁的算法，在分布式系统中，如果站点拥有令牌，则允许其进入关键部分。在这个算法中，所有的站点都被安排成一个有向树，这样树的边就被分配了指向持有令牌的站点的方向。持有令牌的站点也称为树根。

**数据结构和符号:**

*   每个站点 S <sub>i</sub> 保持一个先进先出队列，称为 **request_q**
    该队列存储所有已经向站点 S <sub>i</sub> 发送令牌请求但尚未发送令牌的相邻站点的请求。任何站点的非空 **request_q** 表示该站点已经向根节点发送了 **REQUEST** 消息。
*   每个站点 S <sub>i</sub> 都有一个局部变量，叫做 **holder**
    这个变量指向根节点有向路径上的一个近邻节点。

**算法:**

*   **进入临界区:**
    *   当站点 S <sub>i</sub> 想要进入关键部分时，它会沿着到根的定向路径向节点发送一个**请求**消息，前提是它不持有令牌并且它的 **request_q** 为空。发送 **REQUEST** 消息后，它将其请求添加到其 **request_q** 中。
    *   当到根的路径上的站点 S <sub>j</sub> 接收到站点 S <sub>i</sub> 的 **REQUEST** 消息时，它将 **REQUEST** 放入其 **request_q** 中，并沿着到根的定向路径发送 **REQUEST** 消息，如果它没有为先前接收到的 **REQUEST** 消息发送任何 **REQUEST** 消息的话。
    *   当根站点 S <sub>r</sub> (具有令牌)接收到**请求**消息时，它将令牌发送到请求站点，并将其**持有者**变量设置为指向该站点。
    *   收到令牌后，站点 S <sub>j</sub> 从其 **request_q** 中删除顶部条目，并将令牌发送到删除条目所指示的站点。场地 S <sub>j</sub> 的**支架**变量被设置为指向该场地。
        删除 **request_q** 最顶端的条目后，如果仍为非空 Site S <sub>j</sub> 向 **holder** 变量指示的站点发送 **REQUEST** 消息，以取回令牌。
*   **执行临界区:**
    *   如果站点 S <sub>i</sub> 已经接收到令牌，并且它自己的条目位于其 **request_q** 的顶部，则站点 S<sub>I</sub>执行关键部分。
*   **释放临界段:**
    完成临界段的执行后，站点 S <sub>i</sub> 执行以下操作:
    *   如果它的 **request_q** 不是空的，那么它从它的 **< request_q** 中删除最上面的条目，然后它将令牌发送到被删除条目指示的那个站点，并且它的 **holder** 变量被设置为指向那个站点。
    *   执行上述操作后，如果 **request_q** 仍为非空，则站点 S <sub>i</sub> 向**持有者**变量所指向的站点发送 **REQUEST** 消息，以取回令牌

**消息复杂性:**
在最坏的情况下，算法要求每个关键部分条目有 2 个*(树的最长路径长度)消息调用。如果所有节点都排列在一条直线上，那么最长的路径长度将是**N–1**，因此算法将需要 2 * (N -1)个消息调用来进入关键部分。但是，如果所有节点为该权限生成相同数量的 **REQUEST** 消息，则该算法将需要每个关键部分条目大约 2*N / 3 个消息。

**雷蒙德基于树的算法的缺点:**

*   **会导致饥饿:** Raymond 的算法使用贪婪策略，因为站点可以在接收令牌时执行关键部分，即使它的请求不在请求队列的顶部。这会影响算法的公平性，从而导致饥饿。

**性能:**

*   同步延迟为 **(T * log N )/ 2** ，因为连续执行关键段的两个站点之间的平均距离为 **(Log N)/2** 。这里 T 是最大消息传输时间。
*   在重负载条件下，同步延迟变为 **T** ，因为每次传输令牌时，站点都会执行关键部分。
*   该算法的消息复杂度为 **O(log N)** ，因为具有 **N** 个节点的树中任意两个节点之间的平均距离为 **log N**
*   僵局是不可能的