# 分页中的翻译后备缓冲器(TLB)

> 原文:[https://www . geeksforgeeks . org/translation-latch-buffer-TLB-in-paging/](https://www.geeksforgeeks.org/translation-lookaside-buffer-tlb-in-paging/)

在操作系统(内存管理技术:[分页](https://www.geeksforgeeks.org/operating-system-paging/))中，将为每个进程创建页表，其中将包含[页表条目(PTE)](https://www.geeksforgeeks.org/operating-system-page-table-entries/) 。这个 PTE 将包含像帧号(我们想要引用的主存储器的地址)这样的信息，以及一些其他有用的位(例如，有效/无效位、脏位、保护位等)。该页表条目(PTE)将告诉主存储器中实际页驻留的位置。

现在的问题是把页表放在哪里，这样总的访问时间(或引用时间)会更少。

最初的问题是基于 CPU 产生的地址(即[逻辑/虚拟地址](https://www.geeksforgeeks.org/logical-vs-physical-address-in-operating-system/))快速访问主存内容。最初，有些人想到用寄存器来存储页表，因为它们是高速存储器，所以访问时间会更少。

这里使用的思想是，将页表条目放置在寄存器中，对于从 CPU(虚拟地址)生成的每个请求，它将与页表的适当页码相匹配，现在它将告诉主存储器中相应页驻留的位置。这里看起来一切正常，但问题是寄存器大小很小(实际上，它最多可以容纳 0.5k 到 1k 个页表条目)，并且进程大小可能很大，因此所需的页表也会很大(假设这个页表包含 1M 个条目)，因此寄存器可能不会保存页表的所有 PTE。所以这不是一个实际的方法。

为了克服这个大小问题，整个页表被保存在主内存中。但是这里的问题是需要两个主内存引用:

1.  要找到帧号

2.  前往帧号
    指定的地址

为了克服这个问题，为页表条目建立了一个高速缓存，称为转换后备缓冲器(TLB)。翻译后备缓冲区(TLB)只是一个特殊的缓存，用于跟踪最近使用的事务。TLB 包含最近使用过的页表条目。给定虚拟地址，处理器检查 TLB 是否存在页表条目(TLB 命中)，检索帧号并形成真实地址。如果在 TLB 找不到页表条目(TLB 未命中)，则在处理页表时，页码将用作索引。TLB 首先检查页面是否已经在主存储器中，如果不在主存储器中，则发出页面错误，然后更新 TLB 以包括新的页面条目。

![](img/8658d77b69eca463c4b86da2017f44d4.png)

**TLB 脚步命中:**T2】

1.  CPU 生成虚拟(逻辑)地址。

2.  它在 TLB(现在)托运。

3.  相应的帧号被检索，它现在告诉主存储器页面位于何处。

**TLB 小姐的脚步:**T2】

1.  CPU 生成虚拟(逻辑)地址。

2.  在 TLB 托运(不在现场)。

3.  现在，页码与驻留在主存储器中的页表相匹配(假设页表包含所有 PTE)。

4.  相应的帧号被检索，现在它告诉主存储器页面位于何处。

5.  TLB 更新了新的 PTE(如果没有空间，一种替代技术出现，即先进先出，LRU 或 MFU 等)。

**有效内存访问时间(EMAT) :** TLB 用于减少有效内存访问时间，因为它是高速关联缓存。
**EMAT = h *(c+m)+(1-h)*(c+2m)**
其中，h = hit 命中率
m =内存访问时间
c = TLB 访问时间