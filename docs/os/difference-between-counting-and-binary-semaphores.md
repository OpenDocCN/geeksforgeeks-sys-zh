# 计数和二进制信号量的区别

> 原文:[https://www . geeksforgeeks . org/计数和二进制信号量之间的差异/](https://www.geeksforgeeks.org/difference-between-counting-and-binary-semaphores/)

**先决条件:** [进程同步中的信号量](https://www.geeksforgeeks.org/semaphores-in-process-synchronization/)
**概述**

信号量是一个整数变量，可用于解决各种同步问题。它强加了有意的约束，帮助程序员避免错误。此外，它使解决方案更有条理，使程序可移植且高效。只能通过两个标准的原子操作来访问它:wait()和 signal()。实体是试图访问共享资源的实体。实体可以是进程或线程。在本文中，术语进程和线程可以互换。

有一些保证同步的要求，它们是:

*   互斥现象
*   进步
*   有界等待

根据计数器的范围，信号量可以分为两部分，一部分是*计数信号量，*，另一部分是*二进制信号量。*

**1。二进制信号量:**

1.  二进制信号量是其整数值范围在 0 和 1 之间的信号量。
2.  它没什么，但类似于锁，有两个值:0 和 1。这里 0 表示忙碌，而 1 表示空闲。
3.  使用二进制信号量背后的思想是，它一次只允许一个进程进入关键部分(从而允许它访问共享资源)。
4.  这里，0 表示一个进程或线程处于临界区(即它正在访问共享资源)，而另一个进程或线程应该等待它完成。另一方面，1 表示没有进程访问共享资源，关键部分是空闲的。
5.  它保证了互斥，因为在任何时间点都没有两个进程处于临界区。
6.  因为它只是一个保存整数值的变量，所以不能保证有界等待。一个过程可能永远没有机会进入关键部分，这可能会导致它的饥饿。我们不想这样。

**2。计数信号量:**

1.  计数信号量是具有多个计数器值的信号量。该值的范围可以是不受限制的域。
2.  它是一个结构，包括一个变量，称为信号量变量，可以接受两个以上的值，以及一个任务或实体列表，它只不过是进程或线程。
3.  信号量变量的值是临界区内允许的进程或线程的数量。
4.  计数信号量的值可以在 0 到 N 之间，其中 N 是可以自由进入和退出临界区的进程数。
5.  如上所述，计数信号量可以允许多个进程或线程访问临界区，因此互斥不能保证。
6.  由于进程的多个实例可以在任何时候访问共享资源，计数信号量保证了有限的等待。使用这样的信号量，进入临界区的进程必须等待另一个进程进入临界区，这意味着没有进程会挨饿。

使用这两个信号量，一个进程能够进入临界区，所以取得了进展。

**计数和二进制信号量的区别:**

<figure class="table">

| **标准** | **二进制信号量** | **计数信号量** |
| **定义** | 二进制信号量是其整数值范围在 0 和 1 之间的信号量。 | 计数信号量是具有多个计数器值的信号量。该值的范围可以是不受限制的域。 |
| **结构实现** | typedef struct {
int semaphore _ variable；
} binary _ semaphore； | typedef struct {
int semaphore _ variable；
队列列表；//存储任务列表的队列
}计数 _ 信号量； |
| **表示** | 0 表示一个进程或线程正在访问临界区，其他进程应该等待它退出临界区。1 代表临界区是自由的。 | 该值的范围可以从 0 到 N，其中 N 是必须进入临界区的进程或线程的数量。 |
| **互斥** | 是的，它保证互斥，因为一次只有一个进程或线程可以进入临界区。 | 不，它不能保证互斥，因为一次可以有多个进程或线程进入临界区。 |
| **有界等待** | 不，它不保证有界等待，因为只有一个进程可以进入临界区，并且没有限制该进程在临界区可以存在多长时间，使另一个进程挨饿。 | 是的，它保证了有限的等待，因为它使用一个队列来维护所有进程或线程的列表，并且每个进程或线程都有机会进入临界区一次。所以不存在饥饿的问题。 |

</figure>