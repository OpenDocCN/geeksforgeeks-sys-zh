# 数字逻辑中的二进制表示

> 原文:[https://www . geeksforgeeks . org/二进制数字逻辑表示/](https://www.geeksforgeeks.org/binary-representations-in-digital-logic/)

[二进制](https://www.geeksforgeeks.org/binary-representation-of-a-given-number/)是一个基数为 2 的数字系统，使用两种状态 0 和 1 来表示一个数字。我们也可以称之为真态和假态。二进制数的构建方式与我们构建正常的[十进制数](https://www.geeksforgeeks.org/number-system-and-base-conversions/)的方式相同。

例如，十进制数 45 可以表示为 4*10^1+5*10^0 = 40+5

现在在二进制 45 中表示为 101101。十进制数的幂是 10，二进制数的幂也是 2。因此，二进制数为 101101 的 45 可以表示为:

```
2^0*1+2^1*0+2^2*1+2^3*1+2^4*0+2^5*1 = 45 
```

二进制数从左向右遍历。

**符号和量值表示–**
表示负整数的方式很多。方法之一是符号幅度。这个系统用一个比特来表示符号。数学数字通常由一个符号和值组成。符号表示数字是正数(+)还是负数(–)，而值表示数字的大小。

例如 13、+256 或-574。用这种方式表示数字被称为符号幅度表示，因为最左边的数字可以用来表示符号，其余的数字表示数字的幅度或数值。

符号幅度表示法是表示正数和负数最简单也是最常见的方法之一。因此，简单地通过改变相应正数的符号，例如+2 和-2、+10 和-10 等，就可以得到负数。同样，在二进制数前面加 1 是负数，加 0 是正数。

例如，0101101 代表+45，1101101 代表-45，如果考虑一个二进制数的 6 位数字，最左边的数字代表符号。

但是符号幅度法的一个问题是，它可能导致两个不同的位模式具有相同的二进制值。例如，+0 和-0 分别是 0000 和 1000，作为有符号的 4 位二进制数。因此，使用这种方法，零可以有两种表示形式，正零 0000 和负零 1000，这可能会给计算机和数字系统带来很大的麻烦。

2 *补码*用于表示符号幅度数字的符号是:

**1。补码–**
补码是一种在有符号二进制数系统中表示负二进制数的方法。在补语中，正数和以前一样保持不变。

然而，负数是通过取无符号正数的补码来表示的。因为正数总是以 0 开头，所以补码总是以 1 开头来表示负数。

一个负二进制数的 1 的补码是它的正数的补码，所以要取一个二进制数的 1 的补码，我们需要做的就是从那个数中减去 1，它等于这个数中存在的位数。这也可以通过互换数字来实现。因此 1 的补码是 0，反之亦然。

例如 1010100 的补码:

```
1111111
-1010100
0101011 
```

*数字的补码也可以只通过二进制数*的数字互换来获得。

**2。二进制补码–**
二进制补码是另一种类似于一进制补码形式的方法，我们可以用它来表示有符号二进制数系统中的负二进制数。在二进制补码中，正数与之前的无符号二进制数完全相同。然而，负数由二进制数表示，当二进制数与其对应的正数相加时，结果为零。

在二进制补码表示中，负数是其正数的二进制补码。如果两个数的减法是 X–Y，那么它可以表示为 X+(Y 的 2 补码)。

*二的补码是二进制数的一的补码+1*。

二进制补码相对于前一个二进制补码的主要**优势在于不存在双零问题，生成有符号二进制数的二进制补码要容易得多。在二进制补码中，当数字以二进制补码格式表示时，算术运算相对更容易执行。**

例如用二进制表示-27
27 是:00011011

```
11111111
-00011011
11100100 <-- 1's Complement
      +1
11100101 <-- The 2's Complement 
```

以上 2 种格式实际上可能太长。所以用实数表示。

**实数表示–**
目标是使用以下形式用二进制表示一个带有小数点的数字。IEEE 754 标准定义了如何对实数进行编码。该标准提供了一种使用 32 位(以及 64 位)编码数字的方法，并定义了三个组件:

1.  加号/减号由一位表示，即权重最高的位(最左边)。
2.  指数在符号后立即使用 8 位(64 位表示中的 11 位)进行编码。
3.  尾数(小数点后的位)和剩余的 23 位(64 位表示中的 52 位)。