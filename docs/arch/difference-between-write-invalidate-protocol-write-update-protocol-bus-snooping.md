# 写无效协议&写更新协议(总线监听)

的区别

> 原文:[https://www . geesforgeks . org/difference-write-invalid-protocol-write-update-protocol-bus-snoop/](https://www.geeksforgeeks.org/difference-between-write-invalidate-protocol-write-update-protocol-bus-snooping/)

先决条件–[缓存一致性](https://www.geeksforgeeks.org/cache-coherence/)

**缓存一致性:**
在多处理器系统中，每个处理器都可以有自己的缓存&当允许处理器更新各自缓存块的数据时，数据将处于不一致的状态。这个问题叫做缓存一致性。

**缓存一致性协议:**
为了保持数据的一致性，使用了缓存一致性协议。这些协议更新多处理器系统中的缓存副本。在*总线监听*机制中，处理器监听(监控)总线，并对相关事件(数据更新)采取适当措施，以确保数据一致性。

通常用于更新缓存副本的两个协议是–

1.  写更新协议
2.  写无效协议

**写更新协议:**
使用该协议，如果处理器更新其缓存数据，它会立即更新所有其他缓存副本。广播机制用于将新数据块发送到所有具有副本的缓存。

**写无效协议:**
在这里，不会立即将更新的缓存块发送到另一个缓存。简单地说，一个无效命令被发送到所有其他高速缓存副本&以及共享内存中的原始版本，这样它们的所有数据副本都变得无效。它由“I”表示，并且 I 指定无效/脏数据。

如果现在任何其他处理器(除了更新其高速缓存数据的更新处理器)想要读取数据(高速缓存副本)，则更新处理器向其提供更新的数据。写无效方法用于多处理器系统，如奔腾 4 和 PowerPC。

**写无效协议&写更新协议的区别:**T2】

|   | **写无效协议** | **写入更新协议** |
| 1. | 当对同一个字进行多次写入而没有中间读取时，需要一次初始无效。 | 当对同一个字进行多次写操作而中间没有读操作时，需要多次写广播。 |
| 2. | 对于多字高速缓存块，只有对块中任何字的第一次写入需要产生无效。该协议适用于缓存块。 | 当每个字被写入具有多字高速缓存块的高速缓存块时，需要写广播。该协议对单个单词有效。(字节) |
| 3. | (由另一个非更新处理器)花费更长的时间，因为任何使数据无效的读取都需要您从更新处理器(其缓存已更新数据)获取数据的新副本。 | 读取数据花费的时间更少，因为更新处理器写入的数据也会立即在另一个缓存中更新。(读取处理器应该事先有一个数据副本)(尽管更新所有缓存副本最初可能需要一些时间) |
| 4. | 由于写入的数据不会在读取器的缓存中立即更新，因此在一个处理器中写入一个字和在另一个处理器中读取写入值之间的延迟大于写入更新。 | 因为写入的数据在读取器的高速缓存中被立即更新，所以在写入更新方案中，在一个处理器中写入一个字和在另一个处理器中读取写入值之间的延迟通常更短。 |
| 5. | 更新的数据被提供给需要它的处理器。 | 更新后的数据将提供给包含更新后的相同缓存块副本的处理器。 |
| 6. | 每当处理器频繁修改数据时，更新的数据就会发送给需要它的处理器。不需要再次广播&在数据的每次修改之后。 | 每当处理器频繁修改数据时，每次修改都需要进行写广播。写广播和修改一样多次完成。 |