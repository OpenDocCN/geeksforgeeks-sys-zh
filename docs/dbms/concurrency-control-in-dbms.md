# 数据库管理系统中的并发控制

> 原文:[https://www.geeksforgeeks.org/concurrency-control-in-dbms/](https://www.geeksforgeeks.org/concurrency-control-in-dbms/)

并发控制处理多个事务的**交错执行**。在下一篇文章中，我们将看到什么是可序列化，以及如何发现一个调度是否可序列化。

**什么是交易？**

一组逻辑上相关的操作称为事务。交易的主要操作是:

**Read(A):** Read 操作 Read(A)或 R(A)从数据库中读取 A 的值，并将其存储在主存储器的缓冲区中。

**写(A):** 写操作写(A)或写(A)将值从缓冲区写回数据库。

(注意:它并不总是需要将其写回数据库，它只是将更改写入缓冲区，这就是脏读出现的原因)

让我们从一个包含以下操作的帐户中进行借记交易:

1.  r(A)；
2.  A = A-1000；
3.  w(A)；

假设交易开始前 A 的值为 5000。

*   第一个操作从数据库中读取 A 的值，并将其存储在缓冲区中。
*   第二次操作将使其值减少 1000。所以缓冲区将包含 4000。
*   第三个操作是将缓冲区中的值写入数据库。所以 A 的最终值会是 4000。

但也有可能事务在执行一些操作后会失败。故障可能是由于**硬件、软件或电源**等原因。例如，如果上面讨论的借记交易在执行操作 2 之后失败，则 A 的值将在数据库中保留 5000，这是银行不能接受的。为了避免这种情况，数据库有两个重要的操作:

**提交:**事务的所有指令成功执行后，事务所做的更改将永久保存在数据库中。

**回滚:**如果事务不能成功执行所有操作，事务所做的所有更改都将被撤消。

### **交易的属性**

**原子性:**由于事务是一组逻辑相关的操作，**要么全部执行，要么不执行**。上面讨论的借记交易要么执行所有三个操作，要么不执行。如果借记交易在执行操作 1 和 2 后失败，那么它的新值 4000 将不会在数据库中更新，这将导致不一致。

**一致性:**如果同一账户的借贷交易操作同时执行，可能会使数据库处于不一致状态。

*   例如，T1(借记 Rs。1000 来自 A)和 T2(信用 500 给 A)并发执行，数据库达到不一致状态。
*   让我们假设账户余额为。5000.T1 读取 A(5000)并将该值存储在其本地缓冲空间中。然后，T2 读取 A(5000)，并将该值存储在其本地缓冲空间中。
*   T1 执行 A=A-1000 (5000-1000=4000)，4000 存储在 T1 缓冲空间中。然后 T2 执行 A=A+500 (5000+500=5500)，并且 5500 被存储在 T2 缓冲空间中。T1 将缓冲区中的值写回数据库。
*   在数据库中，a 的值被更新为 4000，然后 T2 将该值从其缓冲区写回数据库。a 的值更新为 5500，这表明借记交易的效果丢失，数据库变得不一致。
*   为了保持数据库的一致性，我们需要**并发控制协议**，这将在下一篇文章中讨论。表 1 显示了 T1 和 T2 的操作及其缓冲区和数据库。

<figure class="table">

| **T1** | **T1 的缓冲空间** | **T2** | **T2 的缓冲空间** | **数据库** |
|   |   |   |   | A=5000 |
| r(A)； | A=5000 |   |   | A=5000 |
|   | A=5000 | r(A)； | A=5000 | A=5000 |
| A = A-1000； | A=4000 |   | A=5000 | A=5000 |
|   | A=4000 | A = A+500； | A=5500 |   |
| w(A)； |   |   | A=5500 | A=4000 |
|   |   | w(A)； |   | A=5500 |

**表 1**

**隔离:**事务提交之前，事务的结果不应该对其他人可见。例如，让我们假设 A 的余额是 Rs。5000 和 T1 借记 Rs。A. A .的新余额中的 1000 将是 4000。如果 T2 信用卢比。500 到 A 的新余额，A 会变成 4500，之后这个 T1 就失效了。然后我们还必须回滚 T2，因为它正在使用 T1 产生的价值。因此，事务结果在提交之前不会对其他事务可见。

**持久:**一旦数据库提交了事务，事务所做的更改应该是永久的。例如:如果一个人在他的账户上存入了 50 万美元，银行不能说更新已经丢失。为了避免这个问题，数据库的多个副本存储在不同的位置。

**什么是时间表？**

计划是一个或多个事务的一系列操作。时间表可以有两种类型:

*   **串行调度:**当一个事务在开始另一个事务之前完全执行时，该调度称为串行调度。连续时间表总是一致的。例如:如果时间表 S 有借方交易 T1 和贷方交易 T2，可能的序列时间表是 T1 后跟 T2 (T1- > T2)或 T2 后跟 T1 ((T2- > T1)。串行调度吞吐量低，资源利用率低。
*   **并发调度:**当一个事务的操作与一个调度的其他事务的操作交错时，该调度称为并发调度。例如:表 1 所示的借贷交易表本质上是并发的。但是并发性会导致数据库的不一致性。上面的并发计划示例也不一致。

**问题:考虑以下涉及两个银行账户 x 和 y 的交易:**

1.  改为(x)；
2.  x:= x–50；
3.  写(x)；
4.  read(y)；
5.  y:= y+50；
6.  写(y)；

帐户 x 和 y 的总和应保持不变的约束是？

1.  原子数
2.  一致性
3.  隔离
4.  持久性

**[2015 年号登机口]**

**解决方案:**如交易的属性中所讨论的，一致性属性表示账户 x 和 y 的总和在交易开始之前和完成之后应该保持不变。所以，正确答案是 b。

下一篇文章- [时间表的可串行化](https://www.geeksforgeeks.org/conflict-serializability-in-dbms/)

Sonal Tuteja 撰写的文章。如果你发现任何不正确的地方，或者你想分享更多关于上面讨论的话题的信息，请写评论。

</figure>