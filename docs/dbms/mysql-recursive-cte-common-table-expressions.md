# MySQL |递归 CTE(常用表表达式)

> 原文:[https://www . geesforgeks . org/MySQL-recursive-cte-common-table-expressions/](https://www.geeksforgeeks.org/mysql-recursive-cte-common-table-expressions/)

**什么是 CTE？**

在 MySQL 中，每个查询都会生成一个临时结果或关系。为了给这些临时结果集命名，使用了 CTE。

*   使用**和**子句定义 CTE。
*   使用 WITH 子句，我们可以在一条语句中定义多个 CTEs。
*   CTE 可以在同一个 wit 子句的其他 cte 中引用，但是这些 cte 应该更早定义。
*   每个 CTE 的范围都存在于它被定义的语句中。

递归 CTE 是一个子查询，它使用自己的名字来引用自己。

*   递归 CTEs 是使用 **WITH RECURSIVE** 子句定义的。
*   递归 CTE 应该有一个终止条件。
*   递归 CTEs 用于分层或树结构数据的系列生成和遍历。

**语法:**

```
WITH RECURSIVE 
cte_name [(col1, col2, ...)]
AS ( subquery )
Select col1, col2, .. from cte_name;

cte_name: Name given to recursive subquery written in subquery block.
col1, col2, ...colN: The name given to columns generated by subquery.
subquery: A MySql query that refer to itself using cte_name as its own name.
```

**此处，**SELECT 语句中给出的列名应与列表中提供的名称匹配，后跟 ***cte_name*** 。

**子查询**块中提供的递归 CTE 结构:

```
Select col1, col2, ... coln from table_name        
UNION [ALL, DISTINCT]
Select col1, col2, ...coln from cte_name          
WHERE clause
```

递归 CTE 由一个非递归子查询和一个递归子查询组成

*   第一条 select 语句是非递归语句，它为结果集提供初始行。
*   UNION [ALL，DISTINCT]用于向先前结果集添加额外的行。使用 ALL 和 DISTINCT 关键字可以包括或消除最后一个结果集中的重复行。
*   第二条 select 语句是递归语句，它迭代地生成结果集，直到 WHERE 子句中提供的条件为真。
*   每次迭代产生的结果集将前一次迭代产生的结果集作为基表。
*   当递归 select 语句不产生任何额外的行时，递归结束。

**示例:**

考虑以下生成一系列前 5 个奇数的查询–
**查询:**

```
WITH RECURSIVE 
odd_no (sr_no, n) AS
(
SELECT 1, 1 
union all
SELECT sr_no+1, n+2 from odd_no where sr_no < 5 
)
SELECT * FROM odd_no;  
```

**输出:**

```
+---------+-------+
| sr_no   |  n    |
+---------+-------+
| 1       |  1    |
| 2       |  3    |
| 3       |  5    |
| 4       |  7    |
| 5       |  9    |
+---------+-------+
```

**说明:**
上面的查询由两部分组成——非递归和递归。

**非递归**部分-它将产生初始行，该初始行由两个名为“sr_no”和“n”的列和单行组成。

```
Query:
SELECT 1, 1 

Output:
+---------+-------+
| sr_no   |  n    |
+---------+-------+
| 1       |  1    |
+---------+-------+
```

**递归**部分-

```
SELECT sr_no+1, n+2 from cte where odd_no < 5 
```

它将在前一个输出中添加行，直到满足终止条件(即 sr_no < 5)。

当 sr_no 变为 5 时，条件变为假，递归终止。

考虑下面的“bst”表-

```
mysql> SELECT * FROM bst order by node;
+------+-----------+
| node | parent    | 
+------+-----------+
|  1   |  NULL     |
|  2   |   1       |
|  3   |   1       |
|  4   |   2       |
|  5   |   2       | 
|  6   |   3       |
|  7   |   3       |
+------+-----------+
```

上表“bst”由两列“node”和“parent”组成，这两列给出了二叉查找树中节点的值及其各自的父值。

**问题描述:**我们要找到给定“bst”中所有节点的路径。

**查询:**

```
WITH RECURSIVE
cte ( node, path )
AS
( SELECT node, cast ( 1 as char(30) )  
          FROM bst WHERE parent IS NULL
  UNION ALL
  SELECT bst.node,  CONCAT ( cte.path, '-->', bst.node ) 
         FROM cte JOIN bst ON cte.node = bst.parent
)
SELECT * FROM cte ORDER BY node;
```

**输出:**

```
+------+-----------+
| node |   path    |
+------+-----------+
|  1   | 1         |
|  2   | 1-->2     |
|  3   | 1-->3     |
|  4   | 1-->2-->4 |
|  5   | 1-->2-->5 |
|  6   | 1-->3-->6 |
|  7   | 1-->3-->7 |
+------+-----------+
```

**说明:**

这里，上面 CTE 中的**非递归**部分将只给出一行，该行由根节点及其路径组成，路径设置为 1。

```
SELECT node, cast ( 1 as char(30) )  
          FROM bst WHERE parent IS NULL

Output:
+------+-----------+
| node |   path    |
+------+-----------+
|  1   | 1         |
+------+-----------+
```

**递归**部分-

```
SELECT bst.node,  CONCAT ( cte.path, '-->', bst.node ) 
         FROM cte JOIN bst ON cte.node = bst.parent
```

递归 SELECT 语句将找到 bst 中的所有节点，这些节点的父节点是上一次迭代中生成的节点。

当上一次迭代中产生的节点(即叶节点)不包含 bst 中的任何子节点时，这种迭代结束。