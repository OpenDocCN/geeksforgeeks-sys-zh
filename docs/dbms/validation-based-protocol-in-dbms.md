# 数据库管理系统中基于验证的协议

> 原文:[https://www . geesforgeks . org/基于验证的数据库中协议/](https://www.geeksforgeeks.org/validation-based-protocol-in-dbms/)

**基于验证的协议**也称为乐观并发控制技术。该协议用于数据库管理系统，以避免事务的并发性。它之所以被称为乐观，是因为它所做的假设，即发生的干扰非常小，因此，在执行事务时不需要进行检查。

在这种技术中，执行事务时不进行检查。在事务结束之前，事务中的更新不会直接应用于数据库。所有更新都应用于为事务保留的数据项的本地副本。在事务执行结束时，当事务执行时，**验证阶段**检查是否有任何事务更新违反了可串行化。如果不违反可序列化性，则提交事务并更新数据库；否则，事务被更新，然后重新启动。

乐观并发控制是一个三阶段协议。基于验证的协议的三个阶段:

1.  **读取阶段:**
    事务可以读取数据库中已提交数据项的值。更新仅适用于本地数据版本。

2.  **验证阶段:**
    执行检查，以确保在将事务更新应用于数据库时不违反可串行化。

3.  **写入阶段:**
    验证阶段成功后，将事务更新应用于数据库，否则，更新将被丢弃，事务将变慢。

乐观并发背后的思想是一次性完成所有检查；因此，事务执行以最小的开销进行，直到到达验证阶段。如果事务之间没有太多的干扰，大多数事务都会成功验证，否则，结果将被丢弃并在以后重新启动。这些情况对优化技术不是很有利，因为干扰较少的假设不被满足。

基于验证的协议对于罕见的冲突很有用。由于回滚中只包含数据的本地副本，因此避免了级联回滚。这种方法不利于较长的事务，因为它们更有可能发生冲突，并且可能由于与较短事务的冲突而被反复回滚。

为了执行验证测试，每个事务都应该经历如上所述的各个阶段。然后，我们必须了解分配给交易 T <sub>i</sub> 的以下三个时间戳，以检查其有效性:

**1。开始(T <sub>i</sub> ):** 是 T <sub>i</sub> 开始执行的时间。

**2。验证(T <sub>i</sub> ):** 正是 T <sub>i</sub> 刚刚完成读取阶段并开始验证阶段的时间。

**3。完成(T<sub>I</sub>):**T<sub>I</sub>结束所有写操作的时间在数据库写阶段。

我们还需要知道两个术语:

**1。一个事务的 Write_set:** 包含了 T <sub>i</sub> 执行的所有写操作。

**2。事务的 Read_set:** 包含了 T <sub>i</sub> 执行的所有读操作。

在事务 T <sub>i</sub> 的验证阶段，协议检查 T <sub>i</sub> 没有与当前处于验证阶段或已提交的任何其他事务重叠或干涉。T <sub>i</sub> 的验证阶段检查所有交易 T <sub>j</sub> 必须满足以下条件之一才能通过验证或通过验证阶段:

**1。** **完成(T <sub>j</sub> ) <开始(T <sub>i</sub> )** ，因为 T <sub>j</sub> 完成其执行意味着在 T <sub>i</sub> 开始其执行(读取阶段)之前完成其写入阶段。那么可串行化确实得以保持。

**2。** T <sub>i</sub> 在 T <sub>j</sub> 完成其写阶段之后开始其写阶段，并且 T <sub>i</sub> 的读 _ 集应该与 T <sub>j</sub> 的写 _ 集不相交。

**3。** T <sub>j</sub> 在 T <sub>i</sub> 完成其读取阶段之前完成其读取阶段，并且 T <sub>i</sub> 的读取 _set 和写入 _set 都与 T <sub>j</sub> 的写入 _set 不相交。

**Ex:这里给出了两个事务 T <sub>i</sub> 和 T <sub>j</sub> ，因为 TS(T<sub>j</sub>)<TS(T<sub>I</sub>)**所以验证阶段在 Schedule-A 中成功。值得注意的是，对数据库的最终写操作仅在 Ti 和 T <sub>j</sub> 验证之后执行。由于 T <sub>i</sub> 读取 **x(12)** 和 **y(15)** 的旧值，而**打印(x+y)** 操作，除非发生最终写入操作。

**时刻表-A**

<figure class="table">

| T <sub>j</sub> | T <sub>i</sub> |
| --- | --- |
| **r(x) // x=12** |   |
|   | **r(x)** |
|   | **x=x-10****r(y) //y=15** |
|   | **y=y+10****r(x)**

 |
| **<验证>****打印(x+y)** |   |
|   | **<验证>** |
|   | **w(x)****w(y)** |

```
                            **Schedule-A is a validated schedule**
```

**<u>优势</u> :**

**1。<u>避免级联回滚</u> :** 这种基于验证的方案避免级联回滚，因为对数据库的最终写操作仅在事务通过验证阶段后执行。如果事务失败，则不会在数据库中执行更新操作。因此不会发生脏读，因此级联回滚的可能性为空。

**2。<u>避免死锁</u> :** 因为使用了严格的基于时间戳的技术来维护事务的特定顺序。因此在这个方案中死锁是不可能的。

**<u>劣势</u>:**T5】

**1。<u>饥饿:</u>** 长期交易可能会出现饥饿，这是由于一系列的短期交易会导致长期交易的重复重启等等。为了避免资源匮乏，必须暂时阻止冲突事务一段时间，以使长期事务得以完成。

</figure>