# 散列连接和排序合并连接的区别

> 原文:[https://www . geesforgeks . org/difference-hash-join-and-sort-merge-join/](https://www.geeksforgeeks.org/difference-between-hash-join-and-sort-merge-join/)

**1。哈希连接:**
在连接运算符的情况下，它也被称为“go-to-guy”。这意味着，如果没有其他连接是首选的(可能是因为没有排序或索引等)，那么，使用哈希连接。当要连接大的、未排序的和未索引的数据(驻留在表中)时，散列连接是最好的算法。哈希连接算法由探测阶段和构建阶段组成。

在两个名为 R 和 S 的关系中，散列连接的算法如下:

```
Hash records of R, one by one, using A values
(Use same M buckets and same hash function h)
Hash matching pair of records into same bucket
End
```

**2。**排序合并连接:
排序合并连接顾名思义，在连接算法中有 2 个阶段，即排序阶段和合并阶段。合并算法是最快的连接算法。这就是排序合并连接在排序关系中最快的原因。假设需要合并 2 个排序关系 R 和 S，算法如下:

```
If R is sorted on A, S is sorted on B do
Merge R and S to get join result
End
```

**散列连接和排序合并连接的区别:**

<center>

| 没有。 | 散列连接 | 排序合并连接 |
| --- | --- | --- |
| 1. | 它专门用于连接较大的表。 | 它通常用于连接表中表示的两个独立数据源。 |
| 2. | 它在大的排序和非索引输入的情况下具有最佳性能。 | 就大型表的性能而言，它比散列连接更好。 |
| 3. | 其中的两个阶段是构建和探测。 | 它由两个阶段组成，包括排序操作和合并操作。 |
| 4. | 所涉及的步骤是在一个小表上构建一个哈希表。它用于探测哈希表的哈希值，适用于第二行的每个元素。 | 取自第一个表的第一行和第二个表的第二行，如果没有结束，则检查所选行是否合并。如果可以合并，则返回合并的行，否则从表中取出下一行，重复这些步骤，直到行用完。 |
| 5. | 在排序表的情况下，它不如排序合并连接快。 | 在排序表的情况下，这是最快的连接操作。这是因为它使用合并阶段和排序阶段，如果排序已经完成，那么合并是最快的操作。 |
| 6. | 其类型有经典散列连接、Grace 散列连接、混合散列连接、散列反连接、散列半连接、递归散列连接和散列救助。 | 它没有进一步的分类。 |
| 7. | 如果没有特定的理由采用其他类型的连接算法，则会自动选择此连接。它也被称为所有 join 运算符中的 go-to 家伙。 | 它不会被自动选择。 |

</center>