# DBMS 中 1NF 和 2NF 的区别

> 原文:[https://www . geesforgeks . org/difference-1nf 和-2nf-in-dbms/](https://www.geeksforgeeks.org/difference-between-1nf-and-2nf-in-dbms/)

**1。** [**【第一范式(1NF)**](https://www.geeksforgeeks.org/first-normal-form-1nf/) **:**
对于任何处于第一范式(1NF)的关系，该关系不应包含任何复合或多值属性。因此，如果一个关系包含原子值，它将处于第一范式。关系应该只包含单值属性。因此，处于第一范式的关系必须遵循以下规则:

*   关系中不应该有重复的组或元素，也就是说，它应该只包含单值属性。
*   应为表中的每个属性指定一个唯一的名称。
*   它不应该包含任何复合属性。

**例:**
考虑以下关系:

<figure class="table">

| 辊号 | 学生姓名 | 马克斯（英格兰人姓氏） |
| --- | --- | --- |
| one | 阿标 | Ninety-six |
| Two | Amit | seventy-eight |
| three | Ayushi | Eighty-six |

这个关系在 1NF 中，因为它不包含任何多值或复合属性。

**2。** [**第二范式(2NF)**](https://www.geeksforgeeks.org/second-normal-form-2nf/) **:**
第二范式的基本概念是全功能依赖。因此，它适用于包含复合键的关系(其中主键由多个属性组成)。所以任何包含单属性主键的关系都是 2NF(第二范式)。因此，为了在 2NF 中，包含复合主键的关系不应该包含任何部分依赖。[当任何非质数属性依赖于候选关键字的任何适当子集时，出现部分依赖](https://practice.geeksforgeeks.org/problems/differentiate-between-full-functional-dependency-and-partial-dependency)。因此，每个非质数属性都应该依赖于关系中每个候选键的整体。因此，一个关系在 2NF 中，如果:

*   它是 1NF(第一范式)。
*   它不包含任何部分依赖关系。

**示例:**
考虑关系 R(X，Y，E，F)的函数依赖关系。

```
{XY->EF, E->F} 
```

因此我们找到了(XY)的闭包，它是{X，Y，E，F}
因为它的闭包包含了关系中的所有属性，所以 XY 是候选键。对于每个功能依赖，即 XY- > EF:
它不包含任何部分依赖，因为非主要属性依赖于整个候选键。
E- > F:它不包含任何部分依赖，因为这里的非主要属性只相互依赖。

**1NF 和 2NF 的区别:**

<figure class="table">

| 没有 | 1NF | 2NF |
| --- | --- | --- |
| 1. | 为了在 1NF 中，任何关系都必须是原子的，并且不应该包含任何复合或多值属性。 | 为了在 2NF 中，任何关系都必须在 1NF 中，并且不应该包含任何部分依赖。 |
| 2. | 对于第一范式，函数依赖的识别是不必要的。 | 函数依赖的识别是第二范式的必要条件。 |
| 3. | 第一范式只处理表的模式，不处理更新异常。 | 第二范式处理更新异常。 |
| 4. | 1NF 中的关系可能在 2NF 中，也可能不在。 | 2NF 中的关系总是 1NF。 |
| 5. | 在第一范式的情况下，主键可以是复合键。 | 在第二范式的情况下，主键不能是复合键，以防它产生任何部分依赖。 |
| 6. | 第一范式的主要目标是消除表中的冗余数据。 | 第二范式的主要目标是实际确保数据依赖。 |
| 7. | 第一范式不如第二范式强。 | 第二范式比第一范式相对更强。 |

</figure>

</figure>