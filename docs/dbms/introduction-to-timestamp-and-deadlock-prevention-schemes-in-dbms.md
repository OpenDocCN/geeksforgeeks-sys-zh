# DBMS 中时间戳和死锁预防方案介绍

> 原文:[https://www . geeksforgeeks . org/introduction-to-timestamp-and-死锁预防方案-in-dbms/](https://www.geeksforgeeks.org/introduction-to-timestamp-and-deadlock-prevention-schemes-in-dbms/)

**死锁**发生在*两个或更多*事务的时间表中的每个事务 **T** 等待集合中某个其他事务 **T <sup>'</sup>** 锁定的某个项目时。因此，两者都处于死锁状态，等待另一方释放该项目的锁。死锁是一个常见的问题，我们通过引入[锁](https://www.geeksforgeeks.org/dbms-concurrency-control-protocols-lock-based-protocol/)在解决并发控制时引入了这个问题。死锁避免是一个主要问题，一些协议被建议避免它们，如[保守 2-PL](https://www.geeksforgeeks.org/dbms-concurrency-control-protocol-two-phase-locking-2-pl-iii/) 和[基于图的协议](https://www.geeksforgeeks.org/dbms-concurrency-control-protocol-graph-based-protocol/)，但是一些缺点仍然存在。

在这里，我们将讨论**事务时间戳 TS(T <sub>i</sub> )** 的新概念。时间戳是由数据库管理系统创建的唯一标识符，用于标识事务。它们通常按照提交给系统的顺序进行分配，因此时间戳可以被认为是事务的开始时间。

可能有不同的生成时间戳的方式

*   一个简单的计数器，每次它的值被分配给一个事务时递增。它们可能被编号为 ***1、2、3……***。尽管我们不得不不时重置计数器以避免溢出。
*   使用系统时钟的当前日期/时间。只要确保在同一个时钟周期内没有两个事务被赋予相同的值，我们将总是得到一个唯一的时间戳。这种方法被广泛使用。

#### 基于时间戳的死锁预防方案…

如上所述，时间戳是分配给每个事务的唯一标识符。它们基于事务开始的顺序。假设**T<sub>1</sub>T3 在**T<sub>2</sub>T7】之前开始，那么 **TS(T <sub>1</sub> )** 将小于(< ) **TS(T <sub>2</sub> )** 。****

有两种防止死锁的方案，分别叫做*缠绕等待*和*等待死亡*。假设有两个事务 **T <sub>i</sub>** 和 **T <sub>j</sub>** ，现在说 **T <sub>i</sub>** 试图锁定一个项目 *X* 但是项目 *X* 已经被一些 **T <sub>j</sub>** 锁定了，现在在这样一个冲突的情况下这两个防止死锁的方案。我们将很快使用这个上下文。

*   **Wait_Die :** 允许较旧的事务等待较新的事务，而请求由较旧事务持有的项目的较新事务被中止并重新启动。
    从以上上下文来看，如果**TS(T<sub>I</sub>)<TS(T<sub>j</sub>)**，那么(T <sub>i</sub> 比 T <sub>j</sub> 大)T <sub>i</sub> 是允许等待的；否则*中止 T <sub>i</sub>* (T <sub>i</sub> 比 T <sub>j</sub> ) *小，稍后用相同的时间戳重新启动。*
*   **wind _ Wait:**与 Wait_Die 技术正好相反。这里，允许一个较年轻的事务等待一个较老的事务，而如果一个较老的事务请求一个由较年轻的事务持有的项目，我们通过中止它来抢占较年轻的事务。
    从上面的上下文来看，如果**TS(T<sub>I</sub>)<TS(T<sub>j</sub>)**，那么(T <sub>i</sub> 比 T <sub>j</sub> 旧)T <sub>j</sub> 被中止(即 T <sub>i</sub> 伤 T <sub>j</sub> )，稍后用相同的时间戳重新启动；*否则(T <sub>i</sub> 比 T <sub>j</sub> 小)T <sub>i</sub> 允许等待。*

因此，这两种方案最终都会中止两个事务中较年轻的一个，这两个事务可能会陷入死锁。这是基于这样的假设，即中止较新的事务将会减少处理的浪费，这是合乎逻辑的。在这种情况下，不可能有周期，因为我们在两种情况下都是线性等待。
对于 GATE 来说，这两种方法的理论就足够了，关于这方面的更多内容，你可以参考这里的。

另一组防止死锁但不需要时间戳的协议。下文将讨论这些问题:

*   **无等待算法:**这遵循一个简单的方法，如果事务无法获得锁，它会立即中止，然后在一定的时间延迟后重新启动，而不检查是否会发生死锁。这里，没有事务等待，所以不存在死锁的可能性。
    这个方法有些不实用。这可能会导致事务不必要的中止和重新启动。
*   **谨慎等待:**如果**T<sub>I</sub>T5】试图锁定一个物品 *X* 但是无法锁定，因为 *X* 被某些 **T <sub>j</sub>** 锁定。在这样的冲突中，如果 **T <sub>j</sub>** 没有在等待某个其他被锁定的项目，那么**T<sub>I</sub>T21 就可以等待，否则*中止**T<sub>I</sub>T26】。*******

另一种处理死锁的方法是死锁检测，我们可以使用[等待图](https://www.geeksforgeeks.org/deadlock-in-dbms/)。当我们在检查可序列化性的同时检查周期时，使用了类似的方法。

**饥饿:**当我们使用锁定时，可能会出现的一个问题是饥饿，当一个事务不能无限期地进行，而系统中的其他事务正常继续时，就会出现饥饿。如果锁定项目的等待方案不公平，使某些交易优先于其他交易，则可能会出现这种情况。我们可能有一些解决饥饿的方法。一种是使用**先来先服务**队列；事务能够按照最初请求锁定的顺序锁定项目。这是一种广泛使用的减少饥饿的机制。我们的并发控制管理器负责调度事务，因此它采用不同的方法来克服它们。详细说明可以参考[本](https://www.geeksforgeeks.org/starvation-in-dbms/)。

试试这个问题: [GATE | GATE-CS-2017(第 1 集)|问题 46](https://www.geeksforgeeks.org/gate-gate-cs-2017-set-1-question-46/)

接下来，我们将讨论著名的时间戳排序协议和 Thomas Write 规则。直到那时快乐学习！

参考资料:数据库系统概念，第五版[西尔伯沙茨，科尔思，苏达山]，第 16 章。