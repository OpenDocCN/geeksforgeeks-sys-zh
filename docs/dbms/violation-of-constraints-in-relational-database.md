# 违反关系数据库中的约束

> 原文:[https://www . geeksforgeeks . org/违反关系数据库中的约束/](https://www.geeksforgeeks.org/violation-of-constraints-in-relational-database/)

在这里，我们将了解由于关系中的任何更改而可能在数据库上发生的违规。

有能力改变关系状态的操作主要有三种，这些修改如下:

1.  **插入–**
    在数据库的关系中插入新的元组。
2.  **删除–**
    删除数据库中的一些现有关系。
3.  **更新(修改)–**
    更改一些现有元组的值。

**插入操作:**
在关系中插入元组时，可能会以下列方式违反约束:

**1。域约束:**
只有当属性的给定值没有出现在对应的域中，或者不是适当的数据类型时，域约束才会被违反。

**例:**
假设域约束说你在关系中插入的所有值都应该大于 10，万一你插入小于 10 的值会导致你违反域约束，所以被拒绝。

**2。实体完整性约束:**
在关系中向新元组的主键的任何部分插入空值都会导致违反实体完整性约束。

**示例:**

```
Insert (NULL, ‘Bikash, ‘M’, ‘Jaipur’, ‘123456’) into EMP 
```

上述插入违反了实体完整性约束，因为
主键 EID 为空，所以不允许，所以被拒绝。

**3。关键约束:**
在一个关系的新元组中插入一个已经存在于同一关系的另一个元组中的值，会导致违反关键约束。

**示例:**

```
Insert (’1200’, ‘Arjun’, ‘9976657777’, ‘Mumbai’) into EMPLOYEE 
```

如果 EID=1200 已经存在于同一关系中的某个元组中，则此插入违反了键约束，因此它会被拒绝。

**参照完整性:**
在关系 1 的外键中插入一个值，而在关系 2 中引用的主键中没有相应的值，在这种情况下，参照完整性被破坏。

**示例:**
当我们试图在表 1 的 EID(外键)中插入一个值，比如说 1200，对于这个值，表 2 没有对应的 EID(主键)，那么它会导致冲突，因此被拒绝。

纠正这种违反的解决方案是，如果任何插入违反了任何约束，那么默认操作是拒绝这种操作。

**删除操作:**
在删除关系中的元组时，可能只会导致违反参照完整性约束。

**参照完整性约束:**
只有当关系 1 中的元组被数据库中表 2 的其他元组中的外键引用时，它才会导致违反，如果发生这种删除，那么表 2 中外键的元组中的值将变为空，这将最终违反参照完整性约束。

下面列出了可能纠正因删除而违反参照完整性的解决方案:

1.  **Restrict–**
    这里我们拒绝删除。
2.  **级联–**
    这里如果删除了父表(引用关系)中的一条记录，那么子表(引用关系)中对应的记录也会自动删除。
3.  **设置 null 或设置默认值–**
    这里我们修改导致冲突的引用属性值，我们设置 NULL 或更改为另一个有效值